{
  "id": "task_202_retry_client",
  "name": "Retry Client with Backoff",
  "description": "HTTP-like client with retry logic and exponential backoff",
  "tier": "tier3_integration",
  "prompt": "Create a retry client with configurable retry logic and exponential backoff.\n\nImplement in src/core/retry_client.py:\n\n1. `RetryConfig` dataclass:\n   - `max_attempts: int` (must be >= 1)\n   - `base_delay: float` (seconds, must be > 0)\n   - `max_delay: float` (seconds, must be >= base_delay)\n   - `exponential_base: float` (must be >= 1, default 2.0)\n   - `retryable_exceptions: tuple` (exception types to retry on)\n\n2. `RetryClient` class:\n   - `__init__(self, config: RetryConfig)`\n   - `execute(self, fn: Callable[[], T]) -> Result[T, RetryError]` - Execute with retry\n   - `execute_with_fallback(self, fn: Callable, fallback: T) -> T` - Execute or return fallback\n   - `get_delay(self, attempt: int) -> float` - Calculate delay for attempt (with jitter)\n   - `attempts_made` property - Number of attempts in last execute\n   - `last_error` property - Last error encountered\n\n3. `RetryError` class:\n   - `attempts: int` - Number of attempts made\n   - `last_exception: Exception` - The last exception\n   - `total_time: float` - Total time spent retrying\n\n4. Use Result type for execute() return value (Success or Failure with RetryError)\n\nContracts should enforce:\n- max_attempts >= 1\n- delays are positive\n- max_delay >= base_delay",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nimport time\nsys.path.insert(0, 'src')\nfrom core.retry_client import RetryClient, RetryConfig, RetryError\n\ndef test_success_first_try():\n    config = RetryConfig(max_attempts=3, base_delay=0.01, max_delay=0.1)\n    client = RetryClient(config)\n    result = client.execute(lambda: \"success\")\n    assert result.unwrap() == \"success\"\n    assert client.attempts_made == 1\n\ndef test_success_after_retry():\n    config = RetryConfig(max_attempts=3, base_delay=0.01, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    attempts = [0]\n    def flaky():\n        attempts[0] += 1\n        if attempts[0] < 2:\n            raise ValueError(\"fail\")\n        return \"success\"\n    result = client.execute(flaky)\n    assert result.unwrap() == \"success\"\n    assert client.attempts_made == 2\n\ndef test_all_attempts_fail():\n    config = RetryConfig(max_attempts=3, base_delay=0.01, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    def always_fail():\n        raise ValueError(\"always fails\")\n    result = client.execute(always_fail)\n    assert result.unwrap_or(None) is None\n    assert client.attempts_made == 3\n\ndef test_execute_with_fallback():\n    config = RetryConfig(max_attempts=2, base_delay=0.01, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    def always_fail():\n        raise ValueError(\"fail\")\n    result = client.execute_with_fallback(always_fail, \"fallback\")\n    assert result == \"fallback\"\n\ndef test_delay_calculation():\n    config = RetryConfig(max_attempts=5, base_delay=1.0, max_delay=10.0, exponential_base=2.0)\n    client = RetryClient(config)\n    # Delays should be exponential: ~1, ~2, ~4, ~8, capped at 10\n    assert client.get_delay(1) >= 0.5  # With jitter\n    assert client.get_delay(1) <= 1.5\n",
  "hidden_test_file": "import pytest\nimport sys\nimport time\nsys.path.insert(0, 'src')\nfrom core.retry_client import RetryClient, RetryConfig, RetryError\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\ndef test_invalid_max_attempts():\n    with pytest.raises(CONTRACT_ERROR):\n        RetryConfig(max_attempts=0, base_delay=0.1, max_delay=1.0)\n\ndef test_invalid_base_delay():\n    with pytest.raises(CONTRACT_ERROR):\n        RetryConfig(max_attempts=3, base_delay=0, max_delay=1.0)\n\ndef test_invalid_max_delay():\n    with pytest.raises(CONTRACT_ERROR):\n        RetryConfig(max_attempts=3, base_delay=1.0, max_delay=0.5)  # max < base\n\ndef test_non_retryable_exception():\n    config = RetryConfig(max_attempts=3, base_delay=0.01, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    def raise_type_error():\n        raise TypeError(\"not retryable\")\n    result = client.execute(raise_type_error)\n    assert result.unwrap_or(None) is None\n    assert client.attempts_made == 1  # Should not retry\n\ndef test_delay_capped_at_max():\n    config = RetryConfig(max_attempts=10, base_delay=1.0, max_delay=5.0, exponential_base=2.0)\n    client = RetryClient(config)\n    delay = client.get_delay(10)  # Would be 512 without cap\n    assert delay <= 5.0 * 1.5  # Allow for jitter\n\ndef test_retry_error_contains_info():\n    config = RetryConfig(max_attempts=2, base_delay=0.01, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    def always_fail():\n        raise ValueError(\"test error\")\n    result = client.execute(always_fail)\n    # Result should be Failure with RetryError\n    error = client.last_error\n    assert error is not None\n    assert error.attempts == 2\n    assert isinstance(error.last_exception, ValueError)\n\ndef test_timing():\n    config = RetryConfig(max_attempts=3, base_delay=0.05, max_delay=0.1, retryable_exceptions=(ValueError,))\n    client = RetryClient(config)\n    def always_fail():\n        raise ValueError(\"fail\")\n    start = time.time()\n    client.execute(always_fail)\n    elapsed = time.time() - start\n    # Should have some delay between attempts\n    assert elapsed >= 0.05  # At least one delay\n\ndef test_exponential_base_one():\n    config = RetryConfig(max_attempts=3, base_delay=0.1, max_delay=1.0, exponential_base=1.0)\n    client = RetryClient(config)\n    # With base 1, all delays should be around base_delay\n    delay1 = client.get_delay(1)\n    delay5 = client.get_delay(5)\n    assert abs(delay1 - delay5) < 0.2  # Should be similar\n",
  "expected_files": [
    "src/core/retry_client.py"
  ],
  "tags": [
    "retry",
    "backoff",
    "result-type",
    "error-handling"
  ],
  "difficulty": "hard"
}
