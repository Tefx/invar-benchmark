{
  "id": "task_203_validator",
  "name": "Composable Validator System",
  "description": "Build a composable validation system with error accumulation",
  "tier": "tier3_integration",
  "prompt": "Create a composable validation system that can accumulate multiple errors.\n\nImplement in src/core/validator.py:\n\n1. `ValidationError` dataclass:\n   - `field: str` - Field that failed validation\n   - `message: str` - Error message\n   - `code: str` - Error code (e.g., 'required', 'min_length', 'pattern')\n\n2. `ValidationResult` class:\n   - `is_valid: bool` property\n   - `errors: list[ValidationError]` property\n   - `add_error(field, message, code)`\n   - `merge(other: ValidationResult)` - Combine two results\n   - `get_errors_for(field: str) -> list[ValidationError]`\n\n3. `Validator` base class/protocol:\n   - `validate(value: Any) -> ValidationResult`\n\n4. Built-in validators:\n   - `Required(field: str)` - Value must not be None or empty\n   - `MinLength(field: str, min_len: int)` - String minimum length\n   - `MaxLength(field: str, max_len: int)` - String maximum length\n   - `Pattern(field: str, regex: str)` - Match regex pattern\n   - `Range(field: str, min_val, max_val)` - Numeric range\n   - `Email(field: str)` - Valid email format\n\n5. `CompositeValidator` class:\n   - `add(validator: Validator)`\n   - `validate(data: dict) -> ValidationResult` - Run all validators\n\n6. `Schema` class for declarative validation:\n   - `Schema.create(rules: dict)` - Create from dict like {'email': [Required(), Email()]}\n   - `validate(data: dict) -> ValidationResult`\n\nContracts should ensure min_length > 0, min_val <= max_val, etc.",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.validator import (\n    ValidationResult, ValidationError,\n    Required, MinLength, MaxLength, Pattern, Range, Email,\n    CompositeValidator, Schema\n)\n\ndef test_required_valid():\n    v = Required(\"name\")\n    result = v.validate({\"name\": \"John\"})\n    assert result.is_valid\n\ndef test_required_missing():\n    v = Required(\"name\")\n    result = v.validate({})\n    assert not result.is_valid\n    assert len(result.errors) == 1\n\ndef test_min_length_valid():\n    v = MinLength(\"password\", 8)\n    result = v.validate({\"password\": \"longpassword\"})\n    assert result.is_valid\n\ndef test_min_length_invalid():\n    v = MinLength(\"password\", 8)\n    result = v.validate({\"password\": \"short\"})\n    assert not result.is_valid\n\ndef test_email_valid():\n    v = Email(\"email\")\n    result = v.validate({\"email\": \"test@example.com\"})\n    assert result.is_valid\n\ndef test_email_invalid():\n    v = Email(\"email\")\n    result = v.validate({\"email\": \"not-an-email\"})\n    assert not result.is_valid\n\ndef test_composite_validator():\n    cv = CompositeValidator()\n    cv.add(Required(\"email\"))\n    cv.add(Email(\"email\"))\n    result = cv.validate({\"email\": \"test@example.com\"})\n    assert result.is_valid\n\ndef test_schema_validation():\n    schema = Schema.create({\n        \"email\": [Required(\"email\"), Email(\"email\")],\n        \"age\": [Required(\"age\"), Range(\"age\", 0, 150)]\n    })\n    result = schema.validate({\"email\": \"a@b.com\", \"age\": 25})\n    assert result.is_valid\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.validator import (\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n    ValidationResult, ValidationError,\n    Required, MinLength, MaxLength, Pattern, Range, Email,\n    CompositeValidator, Schema\n)\n\ndef test_required_empty_string():\n    v = Required(\"name\")\n    result = v.validate({\"name\": \"\"})\n    assert not result.is_valid\n\ndef test_required_none():\n    v = Required(\"name\")\n    result = v.validate({\"name\": None})\n    assert not result.is_valid\n\ndef test_max_length():\n    v = MaxLength(\"bio\", 100)\n    result = v.validate({\"bio\": \"x\" * 101})\n    assert not result.is_valid\n\ndef test_pattern_match():\n    v = Pattern(\"code\", r'^[A-Z]{3}\\d{3}$')\n    result = v.validate({\"code\": \"ABC123\"})\n    assert result.is_valid\n\ndef test_pattern_no_match():\n    v = Pattern(\"code\", r'^[A-Z]{3}\\d{3}$')\n    result = v.validate({\"code\": \"abc123\"})\n    assert not result.is_valid\n\ndef test_range_valid():\n    v = Range(\"age\", 0, 150)\n    result = v.validate({\"age\": 25})\n    assert result.is_valid\n\ndef test_range_below_min():\n    v = Range(\"age\", 0, 150)\n    result = v.validate({\"age\": -1})\n    assert not result.is_valid\n\ndef test_range_above_max():\n    v = Range(\"age\", 0, 150)\n    result = v.validate({\"age\": 200})\n    assert not result.is_valid\n\ndef test_multiple_errors_accumulated():\n    schema = Schema.create({\n        \"email\": [Required(\"email\"), Email(\"email\")],\n        \"password\": [Required(\"password\"), MinLength(\"password\", 8)]\n    })\n    result = schema.validate({})  # Missing both fields\n    assert not result.is_valid\n    assert len(result.errors) >= 2\n\ndef test_get_errors_for_field():\n    schema = Schema.create({\n        \"password\": [Required(\"password\"), MinLength(\"password\", 8)]\n    })\n    result = schema.validate({\"password\": \"short\"})\n    password_errors = result.get_errors_for(\"password\")\n    assert len(password_errors) == 1\n    assert password_errors[0].code == \"min_length\"\n\ndef test_validation_result_merge():\n    r1 = ValidationResult()\n    r1.add_error(\"field1\", \"error1\", \"code1\")\n    r2 = ValidationResult()\n    r2.add_error(\"field2\", \"error2\", \"code2\")\n    r1.merge(r2)\n    assert len(r1.errors) == 2\n\ndef test_invalid_min_length():\n    with pytest.raises(CONTRACT_ERROR):\n        MinLength(\"field\", 0)\n\ndef test_invalid_range():\n    with pytest.raises(CONTRACT_ERROR):\n        Range(\"field\", 100, 50)  # min > max\n\ndef test_various_email_formats():\n    v = Email(\"email\")\n    assert v.validate({\"email\": \"a@b.co\"}).is_valid\n    assert v.validate({\"email\": \"test.name@domain.com\"}).is_valid\n    assert not v.validate({\"email\": \"@domain.com\"}).is_valid\n    assert not v.validate({\"email\": \"test@\"}).is_valid\n",
  "expected_files": [
    "src/core/validator.py"
  ],
  "tags": [
    "validation",
    "composition",
    "error-accumulation",
    "schema"
  ],
  "difficulty": "hard"
}
