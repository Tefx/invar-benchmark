{
  "id": "task_204_scheduler",
  "name": "Task Scheduler with Dependencies",
  "description": "Job scheduler with priority queue and task dependencies",
  "tier": "tier3_integration",
  "prompt": "Create a task scheduler that handles priorities and dependencies.\n\nImplement in src/core/scheduler.py:\n\n1. `TaskStatus` enum: PENDING, READY, RUNNING, COMPLETED, FAILED, CANCELLED\n\n2. `Task` dataclass:\n   - `id: str` (unique identifier)\n   - `name: str`\n   - `priority: int` (higher = more urgent, must be 1-10)\n   - `dependencies: list[str]` (task IDs this depends on)\n   - `status: TaskStatus`\n   - `result: Any` (set when completed)\n   - `error: str` (set when failed)\n\n3. `Scheduler` class:\n   - `add_task(task: Task)` - Add task (fail if duplicate ID)\n   - `remove_task(task_id: str)` - Remove pending task\n   - `get_ready_tasks() -> list[Task]` - Tasks with all deps completed, sorted by priority\n   - `mark_running(task_id: str)` - Transition READY -> RUNNING\n   - `mark_completed(task_id: str, result: Any)` - Transition RUNNING -> COMPLETED\n   - `mark_failed(task_id: str, error: str)` - Transition RUNNING -> FAILED\n   - `cancel_task(task_id: str)` - Cancel task and dependents\n   - `get_task(task_id: str) -> Task | None`\n   - `pending_count` property - count of tasks not yet running (PENDING or READY)\n   - `completed_count` property - count of tasks in COMPLETED status\n   - `has_cycle() -> bool` - Check for circular dependencies\n   - `get_execution_order() -> list[str]` - Topological sort of all tasks\n\n4. State transition rules (enforce with contracts):\n   - PENDING -> READY (when deps completed)\n   - READY -> RUNNING\n   - RUNNING -> COMPLETED | FAILED\n   - Any -> CANCELLED\n\n5. Invariants:\n   - No duplicate task IDs\n   - Priority must be 1-10\n   - Cannot mark_running a non-READY task\n   - Dependencies must exist when task is added",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.scheduler import Scheduler, Task, TaskStatus\n\ndef test_add_task():\n    s = Scheduler()\n    t = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    s.add_task(t)\n    assert s.get_task(\"t1\") is not None\n\ndef test_ready_tasks_no_deps():\n    s = Scheduler()\n    t = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    s.add_task(t)\n    ready = s.get_ready_tasks()\n    assert len(ready) == 1\n    assert ready[0].id == \"t1\"\n\ndef test_ready_tasks_with_deps():\n    s = Scheduler()\n    t1 = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    t2 = Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[\"t1\"])\n    s.add_task(t1)\n    s.add_task(t2)\n    ready = s.get_ready_tasks()\n    assert len(ready) == 1\n    assert ready[0].id == \"t1\"\n\ndef test_priority_ordering():\n    s = Scheduler()\n    s.add_task(Task(id=\"low\", name=\"Low\", priority=1, dependencies=[]))\n    s.add_task(Task(id=\"high\", name=\"High\", priority=10, dependencies=[]))\n    ready = s.get_ready_tasks()\n    assert ready[0].id == \"high\"\n\ndef test_complete_enables_dependent():\n    s = Scheduler()\n    t1 = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    t2 = Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[\"t1\"])\n    s.add_task(t1)\n    s.add_task(t2)\n    s.mark_running(\"t1\")\n    s.mark_completed(\"t1\", \"done\")\n    ready = s.get_ready_tasks()\n    assert any(t.id == \"t2\" for t in ready)\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.scheduler import Scheduler, Task, TaskStatus\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\ndef test_duplicate_task_id():\n    s = Scheduler()\n    s.add_task(Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[]))\n    with pytest.raises(CONTRACT_ERROR):\n        s.add_task(Task(id=\"t1\", name=\"Duplicate\", priority=5, dependencies=[]))\n\ndef test_invalid_priority_low():\n    with pytest.raises(CONTRACT_ERROR):\n        Task(id=\"t1\", name=\"Task\", priority=0, dependencies=[])\n\ndef test_invalid_priority_high():\n    with pytest.raises(CONTRACT_ERROR):\n        Task(id=\"t1\", name=\"Task\", priority=11, dependencies=[])\n\ndef test_dependency_not_found():\n    s = Scheduler()\n    t = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[\"nonexistent\"])\n    with pytest.raises(CONTRACT_ERROR):\n        s.add_task(t)\n\ndef test_mark_running_not_ready():\n    s = Scheduler()\n    t1 = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    t2 = Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[\"t1\"])\n    s.add_task(t1)\n    s.add_task(t2)\n    with pytest.raises(CONTRACT_ERROR):\n        s.mark_running(\"t2\")  # t1 not completed yet\n\ndef test_cycle_detection():\n    s = Scheduler()\n    s.add_task(Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[]))\n    s.add_task(Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[\"t1\"]))\n    # Manually create cycle for test (if API allows)\n    # Or test that adding circular dep fails\n    s2 = Scheduler()\n    s2.add_task(Task(id=\"a\", name=\"A\", priority=5, dependencies=[]))\n    s2.add_task(Task(id=\"b\", name=\"B\", priority=5, dependencies=[\"a\"]))\n    # Check no cycle in valid case\n    assert s2.has_cycle() is False\n\ndef test_cancel_cascades():\n    s = Scheduler()\n    t1 = Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[])\n    t2 = Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[\"t1\"])\n    t3 = Task(id=\"t3\", name=\"Task 3\", priority=5, dependencies=[\"t2\"])\n    s.add_task(t1)\n    s.add_task(t2)\n    s.add_task(t3)\n    s.cancel_task(\"t1\")\n    assert s.get_task(\"t1\").status == TaskStatus.CANCELLED\n    assert s.get_task(\"t2\").status == TaskStatus.CANCELLED\n    assert s.get_task(\"t3\").status == TaskStatus.CANCELLED\n\ndef test_execution_order():\n    s = Scheduler()\n    s.add_task(Task(id=\"a\", name=\"A\", priority=5, dependencies=[]))\n    s.add_task(Task(id=\"b\", name=\"B\", priority=5, dependencies=[\"a\"]))\n    s.add_task(Task(id=\"c\", name=\"C\", priority=5, dependencies=[\"a\", \"b\"]))\n    order = s.get_execution_order()\n    assert order.index(\"a\") < order.index(\"b\")\n    assert order.index(\"b\") < order.index(\"c\")\n\ndef test_pending_completed_counts():\n    s = Scheduler()\n    s.add_task(Task(id=\"t1\", name=\"Task 1\", priority=5, dependencies=[]))\n    s.add_task(Task(id=\"t2\", name=\"Task 2\", priority=5, dependencies=[]))\n    assert s.pending_count == 2\n    assert s.completed_count == 0\n    s.mark_running(\"t1\")\n    s.mark_completed(\"t1\", \"done\")\n    assert s.completed_count == 1\n",
  "expected_files": [
    "src/core/scheduler.py"
  ],
  "tags": [
    "scheduler",
    "state-machine",
    "graph",
    "topological-sort"
  ],
  "difficulty": "hard"
}
