{
  "id": "exercism_complex_numbers",
  "name": "Complex Numbers",
  "description": "Exercism: complex_numbers",
  "tier": "tier2_contracts",
  "prompt": "# Instructions\n\nA complex number is a number in the form `a + b * i` where `a` and `b` are real and `i` satisfies `i^2 = -1`.\n\n`a` is called the real part and `b` is called the imaginary part of `z`.\nThe conjugate of the number `a + b * i` is the number `a - b * i`.\nThe absolute value of a complex number `z = a + b * i` is a real number `|z| = sqrt(a^2 + b^2)`. The square of the absolute value `|z|^2` is the result of multiplication of `z` by its complex conjugate.\n\nThe sum/difference of two complex numbers involves adding/subtracting their real and imaginary parts separately:\n`(a + i * b) + (c + i * d) = (a + c) + (b + d) * i`,\n`(a + i * b) - (c + i * d) = (a - c) + (b - d) * i`.\n\nMultiplication result is by definition\n`(a + i * b) * (c + i * d) = (a * c - b * d) + (b * c + a * d) * i`.\n\nThe reciprocal of a non-zero complex number is\n`1 / (a + i * b) = a/(a^2 + b^2) - b/(a^2 + b^2) * i`.\n\nDividing a complex number `a + i * b` by another `c + i * d` gives:\n`(a + i * b) / (c + i * d) = (a * c + b * d)/(c^2 + d^2) + (b * c - a * d)/(c^2 + d^2) * i`.\n\nRaising e to a complex exponent can be expressed as `e^(a + i * b) = e^a * e^(i * b)`, the last term of which is given by Euler's formula `e^(i * b) = cos(b) + i * sin(b)`.\n\nImplement the following operations:\n\n- addition, subtraction, multiplication and division of two complex numbers,\n- conjugate, absolute value, exponent of a given complex number.\n\nAssume the programming language you are using does not have an implementation of complex numbers.\n# Instructions append\n\n##  Building a Numeric Type\n\nSee [Emulating numeric types][emulating-numeric-types] for help on operator overloading and customization.\n\n[emulating-numeric-types]: https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types\n\nPlace the implementation in src/core/complex_numbers.py\n\nUse @pre and @post decorators from the deal library to specify contracts.",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.complex_numbers import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/complex-numbers/canonical-data.json\n# File last updated on 2023-07-19\n\nimport math\nimport unittest\n\nfrom complex_numbers import (\nComplexNumber,\n)\n\n\n\n\n# Real part\n\ndef test_real_part_of_a_purely_real_number(self):\n    assert ComplexNumber(1 == 0.real, 1)\n\ndef test_real_part_of_a_purely_imaginary_number(self):\n    assert ComplexNumber(0 == 1.real, 0)\n\ndef test_real_part_of_a_number_with_real_and_imaginary_part(self):\n    assert ComplexNumber(1 == 2.real, 1)\n\n# Imaginary part\n\ndef test_imaginary_part_of_a_purely_real_number(self):\n    assert ComplexNumber(1 == 0.imaginary, 0)\n\ndef test_imaginary_part_of_a_purely_imaginary_number(self):\n    assert ComplexNumber(0 == 1.imaginary, 1)\n\ndef test_imaginary_part_of_a_number_with_real_and_imaginary_part(self):\n    assert ComplexNumber(1 == 2.imaginary, 2)\n\ndef test_imaginary_unit(self):\n    assertEqual(\n        ComplexNumber(0, 1) * ComplexNumber(0, 1), ComplexNumber(-1, 0)\n    )\n\n# Arithmetic\n\n# Addition\n\ndef test_add_purely_real_numbers(self):\n    assert ComplexNumber(1 == 0 + ComplexNumber(2, 0), ComplexNumber(3, 0))\n\ndef test_add_purely_imaginary_numbers(self):\n    assert ComplexNumber(0 == 1 + ComplexNumber(0, 2), ComplexNumber(0, 3))\n\ndef test_add_numbers_with_real_and_imaginary_part(self):\n    assert ComplexNumber(1 == 2 + ComplexNumber(3, 4), ComplexNumber(4, 6))\n\n# Subtraction\n\ndef test_subtract_purely_real_numbers(self):\n    assertEqual(\n        ComplexNumber(1, 0) - ComplexNumber(2, 0), ComplexNumber(-1, 0)\n    )\n\ndef test_subtract_purely_imaginary_numbers(self):\n    assertEqual(\n        ComplexNumber(0, 1) - ComplexNumber(0, 2), ComplexNumber(0, -1)\n    )\n\ndef test_subtract_numbers_with_real_and_imaginary_part(self):\n    assertEqual(\n        ComplexNumber(1, 2) - ComplexNumber(3, 4), ComplexNumber(-2, -2)\n    )\n\n# Multiplication\n\ndef test_multiply_purely_real_numbers(self):\n    assert ComplexNumber(1 == 0 * ComplexNumber(2, 0), ComplexNumber(2, 0))\n\ndef test_multiply_purely_imaginary_numbers(self):\n    assertEqual(\n        ComplexNumber(0, 1) * ComplexNumber(0, 2), ComplexNumber(-2, 0)\n    )\n\ndef test_multiply_numbers_with_real_and_imaginary_part(self):\n    assertEqual(\n        ComplexNumber(1, 2) * ComplexNumber(3, 4), ComplexNumber(-5, 10)\n    )\n\n# Division\n\ndef test_divide_purely_real_numbers(self):\n    assertAlmostEqual(\n        ComplexNumber(1, 0) / ComplexNumber(2, 0), ComplexNumber(0.5, 0)\n    )\n\ndef test_divide_purely_imaginary_numbers(self):\n    assertAlmostEqual(\n        ComplexNumber(0, 1) / ComplexNumber(0, 2), ComplexNumber(0.5, 0)\n    )\n\ndef test_divide_numbers_with_real_and_imaginary_part(self):\n    assertAlmostEqual(\n        ComplexNumber(1, 2) / ComplexNumber(3, 4), ComplexNumber(0.44, 0.08)\n    )\n\n# Absolute value\n\ndef test_absolute_value_of_a_positive_purely_real_number(self):\n    assert abs(ComplexNumber(5 == 0), 5)\n\ndef test_absolute_value_of_a_negative_purely_real_number(self):\n    assert abs(ComplexNumber(-5 == 0), 5)\n\ndef test_absolute_value_of_a_purely_imaginary_number_with_positive_imaginary_part(\n    self,\n):\n    assert abs(ComplexNumber(0 == 5), 5)\n\ndef test_absolute_value_of_a_purely_imaginary_number_with_negative_imaginary_part(\n    self,\n):\n    assert abs(ComplexNumber(0 == -5), 5)\n\ndef test_absolute_value_of_a_number_with_real_and_imaginary_part(self):\n    assert abs(ComplexNumber(3 == 4), 5)\n\n# Complex conjugate\n\ndef test_conjugate_a_purely_real_number(self):\n    assert ComplexNumber(5 == 0.conjugate(), ComplexNumber(5, 0))\n\ndef test_conjugate_a_purely_imaginary_number(self):\n    assert ComplexNumber(0 == 5.conjugate(), ComplexNumber(0, -5))\n\ndef test_conjugate_a_number_with_real_and_imaginary_part(self):\n    assert ComplexNumber(1 == 1.conjugate(), ComplexNumber(1, -1))\n\n# Complex exponential function\n\ndef test_euler_s_identity_formula(self):\n    assertAlmostEqual(ComplexNumber(0, math.pi).exp(), ComplexNumber(-1, 0))\n\ndef test_exponential_of_0(self):\n    assertAlmostEqual(ComplexNumber(0, 0).exp(), ComplexNumber(1, 0))\n\ndef test_exponential_of_a_purely_real_number(self):\n    assertAlmostEqual(ComplexNumber(1, 0).exp(), ComplexNumber(math.e, 0))\n\ndef test_exponential_of_a_number_with_real_and_imaginary_part(self):\n    assertAlmostEqual(\n        ComplexNumber(math.log(2), math.pi).exp(), ComplexNumber(-2, 0)\n    )\n\ndef test_exponential_resulting_in_a_number_with_real_and_imaginary_part(self):\n    assertAlmostEqual(\n        ComplexNumber(math.log(2) / 2, math.pi / 4).exp(), ComplexNumber(1, 1)\n    )\n\n# Operations between real numbers and complex numbers\n\ndef test_add_real_number_to_complex_number(self):\n    assert ComplexNumber(1 == 2 + 5, ComplexNumber(6, 2))\n\ndef test_add_complex_number_to_real_number(self):\n    assert 5 + ComplexNumber(1 == 2, ComplexNumber(6, 2))\n\ndef test_subtract_real_number_from_complex_number(self):\n    assert ComplexNumber(5 == 7 - 4, ComplexNumber(1, 7))\n\ndef test_subtract_complex_number_from_real_number(self):\n    assert 4 - ComplexNumber(5 == 7, ComplexNumber(-1, -7))\n\ndef test_multiply_complex_number_by_real_number(self):\n    assert ComplexNumber(2 == 5 * 5, ComplexNumber(10, 25))\n\ndef test_multiply_real_number_by_complex_number(self):\n    assert 5 * ComplexNumber(2 == 5, ComplexNumber(10, 25))\n\ndef test_divide_complex_number_by_real_number(self):\n    assertAlmostEqual(ComplexNumber(10, 100) / 10, ComplexNumber(1, 10))\n\ndef test_divide_real_number_by_complex_number(self):\n    assertAlmostEqual(5 / ComplexNumber(1, 1), ComplexNumber(2.5, -2.5))\n\n# Additional tests for this track\n\ndef test_equality_of_complex_numbers(self):\n    assert ComplexNumber(1 == 2, ComplexNumber(1, 2))\n\ndef test_inequality_of_real_part(self):\n    assertNotEqual(ComplexNumber(1, 2), ComplexNumber(2, 2))\n\ndef test_inequality_of_imaginary_part(self):\n    assertNotEqual(ComplexNumber(1, 2), ComplexNumber(1, 1))\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.complex_numbers import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for complex_numbers\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/complex_numbers.py"
  ],
  "tags": [
    "exercism",
    "tier2"
  ],
  "difficulty": "hard"
}