{
  "id": "exercism_bank_account",
  "name": "Bank Account",
  "description": "Exercism: bank_account",
  "tier": "tier2_contracts",
  "prompt": "# Introduction\n\nAfter years of filling out forms and waiting, you've finally acquired your banking license.\nThis means you are now officially eligible to open your own bank, hurray!\n\nYour first priority is to get the IT systems up and running.\nAfter a day of hard work, you can already open and close accounts, as well as handle withdrawals and deposits.\n\nSince you couldn't be bothered writing tests, you invite some friends to help test the system.\nHowever, after just five minutes, one of your friends claims they've lost money!\nWhile you're confident your code is bug-free, you start looking through the logs to investigate.\n\nAh yes, just as you suspected, your friend is at fault!\nThey shared their test credentials with another friend, and together they conspired to make deposits and withdrawals from the same account _in parallel_.\nWho would do such a thing?\n\nWhile you argue that it's physically _impossible_ for someone to access their account in parallel, your friend smugly notifies you that the banking rules _require_ you to support this.\nThus, no parallel banking support, no go-live signal.\nSighing, you create a mental note to work on this tomorrow.\nThis will set your launch date back at _least_ one more day, but well...\n# Instructions\n\nYour task is to implement bank accounts supporting opening/closing, withdrawals, and deposits of money.\n\nAs bank accounts can be accessed in many different ways (internet, mobile phones, automatic charges), your bank software must allow accounts to be safely accessed from multiple threads/processes (terminology depends on your programming language) in parallel.\nFor example, there may be many deposits and withdrawals occurring in parallel; you need to ensure there are no [race conditions][wikipedia] between when you read the account balance and set the new balance.\n\nIt should be possible to close an account; operations against a closed account must fail.\n\n[wikipedia]: https://en.wikipedia.org/wiki/Race_condition#In_software\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` for when an account is or is not open, or the withdrawal/deposit amounts are incorrect. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:  \n\n\n```python\n# account is not open\nraise ValueError('account not open')\n\n# account is already open\nraise ValueError('account already open')\n\n# incorrect withdrawal/deposit amount\nraise ValueError('amount must be greater than 0')\n\n# withdrawal is too big\nraise ValueError('amount must be less than balance')\n```\n\nPlace the implementation in src/core/bank_account.py\n\nUse @pre and @post decorators from the deal library to specify contracts.",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.bank_account import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/bank-account/canonical-data.json\n# File last updated on 2023-07-20\n\nimport unittest\n\nfrom bank_account import (\nBankAccount,\n)\n\n\n\ndef test_newly_opened_account_has_zero_balance():\n    account = BankAccount()\n    account.open()\n    assert account.get_balance() == 0\n\ndef test_single_deposit():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    assert account.get_balance() == 100\n\ndef test_multiple_deposits():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    account.deposit(50)\n    assert account.get_balance() == 150\n\ndef test_withdraw_once():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    account.withdraw(75)\n    assert account.get_balance() == 25\n\ndef test_withdraw_twice():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    account.withdraw(80)\n    account.withdraw(20)\n    assert account.get_balance() == 0\n\ndef test_can_do_multiple_operations_sequentially():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    account.deposit(110)\n    account.withdraw(200)\n    account.deposit(60)\n    account.withdraw(50)\n    assert account.get_balance() == 20\n\ndef test_cannot_check_balance_of_closed_account():\n    account = BankAccount()\n    account.open()\n    account.close()\n    with pytest.raises(ValueError) as err:\n        account.get_balance()\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account not open\"\n\ndef test_cannot_deposit_into_closed_account():\n    account = BankAccount()\n    account.open()\n    account.close()\n    with pytest.raises(ValueError) as err:\n        account.deposit(50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account not open\"\n\ndef test_cannot_deposit_into_unopened_account():\n    account = BankAccount()\n    with pytest.raises(ValueError) as err:\n        account.deposit(50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account not open\"\n\ndef test_cannot_withdraw_from_closed_account():\n    account = BankAccount()\n    account.open()\n    account.close()\n    with pytest.raises(ValueError) as err:\n        account.withdraw(50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account not open\"\n\ndef test_cannot_close_an_account_that_was_not_opened():\n    account = BankAccount()\n    with pytest.raises(ValueError) as err:\n        account.close()\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account not open\"\n\ndef test_cannot_open_an_already_opened_account():\n    account = BankAccount()\n    account.open()\n    with pytest.raises(ValueError) as err:\n        account.open()\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"account already open\"\n\ndef test_reopened_account_does_not_retain_balance():\n    account = BankAccount()\n    account.open()\n    account.deposit(50)\n    account.close()\n    account.open()\n    assert account.get_balance() == 0\n\ndef test_cannot_withdraw_more_than_deposited():\n    account = BankAccount()\n    account.open()\n    account.deposit(25)\n    with pytest.raises(ValueError) as err:\n        account.withdraw(50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"amount must be less than balance\"\n\ndef test_cannot_withdraw_negative():\n    account = BankAccount()\n    account.open()\n    account.deposit(100)\n    with pytest.raises(ValueError) as err:\n        account.withdraw(-50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"amount must be greater than 0\"\n\ndef test_cannot_deposit_negative():\n    account = BankAccount()\n    account.open()\n    with pytest.raises(ValueError) as err:\n        account.deposit(-50)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"amount must be greater than 0\"\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.bank_account import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for bank_account\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/bank_account.py"
  ],
  "tags": [
    "exercism",
    "tier2"
  ],
  "difficulty": "hard"
}