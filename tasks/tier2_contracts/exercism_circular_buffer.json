{
  "id": "exercism_circular_buffer",
  "name": "Circular Buffer",
  "description": "Exercism: circular_buffer",
  "tier": "tier2_contracts",
  "prompt": "# Instructions\n\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\n\nA circular buffer first starts empty and of some predefined length.\nFor example, this is a 7-element buffer:\n\n```text\n[ ][ ][ ][ ][ ][ ][ ]\n```\n\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\n\n```text\n[ ][ ][ ][1][ ][ ][ ]\n```\n\nThen assume that two more elements are added \u2014 2 & 3 \u2014 which get appended after the 1:\n\n```text\n[ ][ ][ ][1][2][3][ ]\n```\n\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\n\n```text\n[ ][ ][ ][ ][ ][3][ ]\n```\n\nIf the buffer has 7 elements then it is completely full:\n\n```text\n[5][6][7][8][9][3][4]\n```\n\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\n\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\nIn this case, two more elements \u2014 A & B \u2014 are added and they overwrite the 3 & 4:\n\n```text\n[5][6][7][8][9][A][B]\n```\n\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\n\n```text\n[ ][ ][7][8][9][A][B]\n```\n\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\n7 is still the oldest element and the buffer is once again full.\n\n```text\n[C][D][7][8][9][A][B]\n```\n# Instructions append\n\n## Customizing and Raising Exceptions\n\nSometimes it is necessary to both [customize](https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions) and [`raise`](https://docs.python.org/3/tutorial/errors.html#raising-exceptions) exceptions in your code. When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. \n\nCustom exceptions can be created through new exception classes (see [`classes`](https://docs.python.org/3/tutorial/classes.html#tut-classes) for more detail.) that are typically subclasses of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception).\n\nFor situations where you know the error source will be a derivative of a certain exception type, you can choose to inherit from one of the [`built in error types`](https://docs.python.org/3/library/exceptions.html#base-classes) under the _Exception_ class. When raising the error, you should still include a meaningful message.\n\nThis particular exercise requires that you create two _custom exceptions_.  One exception to be [raised](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement)/\"thrown\" when your circular buffer is **full**, and one for when it is **empty**. The tests will only pass if you customize appropriate exceptions, `raise` those exceptions, and include appropriate error messages.\n\nTo customize a `built-in exception`, create a `class` that inherits from that exception. When raising the custom exception with a message, write the message as an argument to the `exception` type:\n\n```python\n# subclassing the built-in BufferError to create BufferFullException\nclass BufferFullException(BufferError):\n    \"\"\"Exception raised when CircularBuffer is full.\n\n    message: explanation of the error.\n\n    \"\"\"\n    def __init__(self, message):\n        self.message = message\n\n        \n# raising a BufferFullException\nraise BufferFullException(\"Circular buffer is full\")\n```\n\nPlace the implementation in src/core/circular_buffer.py\n\nUse @pre and @post decorators from the deal library to specify contracts.",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.circular_buffer import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/circular-buffer/canonical-data.json\n# File last updated on 2023-07-20\n\nimport unittest\n\nfrom circular_buffer import (\nCircularBuffer,\nBufferEmptyException,\nBufferFullException,\n)\n\n\n\ndef test_reading_empty_buffer_should_fail():\n    buf = CircularBuffer(1)\n    with pytest.raises(BufferError) as err:\n        buf.read()\n\n    assert type(err.exception) == BufferEmptyException\n    assert err.exception.args[0] == \"Circular buffer is empty\"\n\ndef test_can_read_an_item_just_written():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    assert buf.read() == \"1\"\n\ndef test_each_item_may_only_be_read_once():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    assert buf.read() == \"1\"\n    with pytest.raises(BufferError) as err:\n        buf.read()\n\n    assert type(err.exception) == BufferEmptyException\n    assert err.exception.args[0] == \"Circular buffer is empty\"\n\ndef test_items_are_read_in_the_order_they_are_written():\n    buf = CircularBuffer(2)\n    buf.write(\"1\")\n    buf.write(\"2\")\n    assert buf.read() == \"1\"\n    assert buf.read() == \"2\"\n\ndef test_full_buffer_can_t_be_written_to():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    with pytest.raises(BufferError) as err:\n        buf.write(\"2\")\n\n    assert type(err.exception) == BufferFullException\n    assert err.exception.args[0] == \"Circular buffer is full\"\n\ndef test_a_read_frees_up_capacity_for_another_write():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    assert buf.read() == \"1\"\n    buf.write(\"2\")\n    assert buf.read() == \"2\"\n\ndef test_read_position_is_maintained_even_across_multiple_writes():\n    buf = CircularBuffer(3)\n    buf.write(\"1\")\n    buf.write(\"2\")\n    assert buf.read() == \"1\"\n    buf.write(\"3\")\n    assert buf.read() == \"2\"\n    assert buf.read() == \"3\"\n\ndef test_items_cleared_out_of_buffer_can_t_be_read():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    buf.clear()\n    with pytest.raises(BufferError) as err:\n        buf.read()\n\n    assert type(err.exception) == BufferEmptyException\n    assert err.exception.args[0] == \"Circular buffer is empty\"\n\ndef test_clear_frees_up_capacity_for_another_write():\n    buf = CircularBuffer(1)\n    buf.write(\"1\")\n    buf.clear()\n    buf.write(\"2\")\n    assert buf.read() == \"2\"\n\ndef test_clear_does_nothing_on_empty_buffer():\n    buf = CircularBuffer(1)\n    buf.clear()\n    buf.write(\"1\")\n    assert buf.read() == \"1\"\n\ndef test_overwrite_acts_like_write_on_non_full_buffer():\n    buf = CircularBuffer(2)\n    buf.write(\"1\")\n    buf.overwrite(\"2\")\n    assert buf.read() == \"1\"\n    assert buf.read() == \"2\"\n\ndef test_overwrite_replaces_the_oldest_item_on_full_buffer():\n    buf = CircularBuffer(2)\n    buf.write(\"1\")\n    buf.write(\"2\")\n    buf.overwrite(\"3\")\n    assert buf.read() == \"2\"\n    assert buf.read() == \"3\"\n\ndef test_overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read(\n    self,\n):\n    buf = CircularBuffer(3)\n    buf.write(\"1\")\n    buf.write(\"2\")\n    buf.write(\"3\")\n    assert buf.read() == \"1\"\n    buf.write(\"4\")\n    buf.overwrite(\"5\")\n    assert buf.read() == \"3\"\n    assert buf.read() == \"4\"\n    assert buf.read() == \"5\"\n\ndef test_initial_clear_does_not_affect_wrapping_around():\n    buf = CircularBuffer(2)\n    buf.clear()\n    buf.write(\"1\")\n    buf.write(\"2\")\n    buf.overwrite(\"3\")\n    buf.overwrite(\"4\")\n    assert buf.read() == \"3\"\n    assert buf.read() == \"4\"\n    with pytest.raises(BufferError) as err:\n        buf.read()\n\n    assert type(err.exception) == BufferEmptyException\n    assert err.exception.args[0] == \"Circular buffer is empty\"\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.circular_buffer import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for circular_buffer\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/circular_buffer.py"
  ],
  "tags": [
    "exercism",
    "tier2"
  ],
  "difficulty": "hard"
}