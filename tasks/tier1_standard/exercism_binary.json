{
  "id": "exercism_binary",
  "name": "Binary",
  "description": "Exercism: binary",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nConvert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles.\n\nImplement binary to decimal conversion.\nGiven a binary input string, your program should produce a decimal output.\nThe program should handle invalid inputs.\n\n## Note\n\n- Implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n\n## About Binary (Base-2)\n\nDecimal is a base-10 system.\n\nA number 23 in base 10 notation can be understood as a linear combination of powers of 10:\n\n- The rightmost digit gets multiplied by 10^0 = 1\n- The next number gets multiplied by 10^1 = 10\n- ...\n- The *n*th number gets multiplied by 10^*(n-1)*.\n- All these values are summed.\n\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\n\nBinary is similar, but uses powers of 2 rather than powers of 10.\n\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` when the argument passed is not a valid binary literal. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# example when the argument passed is not a valid binary literal\nraise ValueError(\"Invalid binary literal: \" + digits)\n```\n\nPlace the implementation in src/core/binary.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.binary import *\n\n\"\"\"Tests for the binary exercise\n\nImplementation note:\nIf the argument to parse_binary isn't a valid binary number the\nfunction should raise a ValueError with a meaningful error message.\n\"\"\"\nimport unittest\n\nfrom binary import parse_binary\n\n\n\ndef test_binary_1_is_decimal_1(self):\n    assert parse_binary(\"1\") == 1\n\ndef test_binary_10_is_decimal_2(self):\n    assert parse_binary(\"10\") == 2\n\ndef test_binary_11_is_decimal_3(self):\n    assert parse_binary(\"11\") == 3\n\ndef test_binary_100_is_decimal_4(self):\n    assert parse_binary(\"100\") == 4\n\ndef test_binary_1001_is_decimal_9(self):\n    assert parse_binary(\"1001\") == 9\n\ndef test_binary_11010_is_decimal_26(self):\n    assert parse_binary(\"11010\") == 26\n\ndef test_binary_10001101000_is_decimal_1128(self):\n    assert parse_binary(\"10001101000\") == 1128\n\ndef test_invalid_binary_text_only(self):\n    with pytest.raises(ValueError) as err:\n        parse_binary(\"carrot\")\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Invalid binary literal: carrot\"\n\ndef test_invalid_binary_number_not_base2(self):\n    with pytest.raises(ValueError) as err:\n        parse_binary(\"102011\")\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Invalid binary literal: 102011\"\n\ndef test_invalid_binary_numbers_with_text(self):\n    with pytest.raises(ValueError) as err:\n        parse_binary(\"10nope\")\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Invalid binary literal: 10nope\"\n\ndef test_invalid_binary_text_with_numbers(self):\n    with pytest.raises(ValueError) as err:\n        parse_binary(\"nope10\")\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Invalid binary literal: nope10\"\n\nif __name__ == '__main__':\nunittest.main()\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.binary import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for binary\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/binary.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}