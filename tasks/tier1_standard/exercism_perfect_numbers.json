{
  "id": "exercism_perfect_numbers",
  "name": "Perfect Numbers",
  "description": "Exercism: perfect_numbers",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nDetermine if a number is perfect, abundant, or deficient based on Nicomachus' (60 - 120 CE) classification scheme for positive integers.\n\nThe Greek mathematician [Nicomachus][nicomachus] devised a classification scheme for positive integers, identifying each as belonging uniquely to the categories of [perfect](#perfect), [abundant](#abundant), or [deficient](#deficient) based on their [aliquot sum][aliquot-sum].\nThe _aliquot sum_ is defined as the sum of the factors of a number not including the number itself.\nFor example, the aliquot sum of `15` is `1 + 3 + 5 = 9`.\n\n## Perfect\n\nA number is perfect when it equals its aliquot sum.\nFor example:\n\n- `6` is a perfect number because `1 + 2 + 3 = 6`\n- `28` is a perfect number because `1 + 2 + 4 + 7 + 14 = 28`\n\n## Abundant\n\nA number is abundant when it is less than its aliquot sum.\nFor example:\n\n- `12` is an abundant number because `1 + 2 + 3 + 4 + 6 = 16`\n- `24` is an abundant number because `1 + 2 + 3 + 4 + 6 + 8 + 12 = 36`\n\n## Deficient\n\nA number is deficient when it is greater than its aliquot sum.\nFor example:\n\n- `8` is a deficient number because `1 + 2 + 4 = 7`\n- Prime numbers are deficient\n\n## Task\n\nImplement a way to determine whether a given number is [perfect](#perfect).\nDepending on your language track, you may also need to implement a way to determine whether a given number is [abundant](#abundant) or [deficient](#deficient).\n\n[nicomachus]: https://en.wikipedia.org/wiki/Nicomachus\n[aliquot-sum]: https://en.wikipedia.org/wiki/Aliquot_sum\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` if the `classify()` function is passed a number that is not a _positive integer_.  The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# if a number to be classified is less than 1.\nraise ValueError(\"Classification is only possible for positive integers.\")\n```\n\nPlace the implementation in src/core/perfect_numbers.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.perfect_numbers import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/perfect-numbers/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom perfect_numbers import (\nclassify,\n)\n\n\n\ndef test_smallest_perfect_number_is_classified_correctly():\n    assert classify(6) == \"perfect\"\n\ndef test_medium_perfect_number_is_classified_correctly():\n    assert classify(28) == \"perfect\"\n\ndef test_large_perfect_number_is_classified_correctly():\n    assert classify(33550336) == \"perfect\"\n\n\n\ndef test_smallest_abundant_number_is_classified_correctly():\n    assert classify(12) == \"abundant\"\n\ndef test_medium_abundant_number_is_classified_correctly():\n    assert classify(30) == \"abundant\"\n\ndef test_large_abundant_number_is_classified_correctly():\n    assert classify(33550335) == \"abundant\"\n\n\n\ndef test_smallest_prime_deficient_number_is_classified_correctly():\n    assert classify(2) == \"deficient\"\n\ndef test_smallest_non_prime_deficient_number_is_classified_correctly():\n    assert classify(4) == \"deficient\"\n\ndef test_medium_deficient_number_is_classified_correctly():\n    assert classify(32) == \"deficient\"\n\ndef test_large_deficient_number_is_classified_correctly():\n    assert classify(33550337) == \"deficient\"\n\ndef test_edge_case_no_factors_other_than_itself_is_classified_correctly():\n    assert classify(1) == \"deficient\"\n\n\n\ndef test_zero_is_rejected_as_it_is_not_a_positive_integer():\n    with pytest.raises(ValueError) as err:\n        classify(0)\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0],\n        \"Classification is only possible for positive integers.\",\n    )\n\ndef test_negative_integer_is_rejected_as_it_is_not_a_positive_integer():\n    with pytest.raises(ValueError) as err:\n        classify(-1)\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0],\n        \"Classification is only possible for positive integers.\",\n    )\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.perfect_numbers import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for perfect_numbers\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/perfect_numbers.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}