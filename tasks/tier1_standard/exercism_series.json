{
  "id": "exercism_series",
  "name": "Series",
  "description": "Exercism: series",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nGiven a string of digits, output all the contiguous substrings of length `n` in that string in the order that they appear.\n\nFor example, the string \"49142\" has the following 3-digit series:\n\n- \"491\"\n- \"914\"\n- \"142\"\n\nAnd the following 4-digit series:\n\n- \"4914\"\n- \"9142\"\n\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.\n\nNote that these series are only required to occupy _adjacent positions_ in the input;\nthe digits need not be _numerically consecutive_.\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` if the series and/or length parameters input into the `slice()` function are empty or out of range. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# if the slice length is zero.\nraise ValueError(\"slice length cannot be zero\")\n\n# if the slice length is negative.\nraise ValueError(\"slice length cannot be negative\")\n\n# if the series provided is empty.\nraise ValueError(\"series cannot be empty\")\n\n# if the slice length is longer than the series.\nraise ValueError(\"slice length cannot be greater than series length\")\n```\n\nPlace the implementation in src/core/series.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.series import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/series/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom series import (\nslices,\n)\n\n\n\ndef test_slices_of_one_from_one(self):\n    assert slices(\"1\" == 1, [\"1\"])\n\ndef test_slices_of_one_from_two(self):\n    assert slices(\"12\" == 1, [\"1\", \"2\"])\n\ndef test_slices_of_two(self):\n    assert slices(\"35\" == 2, [\"35\"])\n\ndef test_slices_of_two_overlap(self):\n    assert slices(\"9142\" == 2, [\"91\", \"14\", \"42\"])\n\ndef test_slices_can_include_duplicates(self):\n    assert slices(\"777777\" == 3, [\"777\", \"777\", \"777\", \"777\"])\n\ndef test_slices_of_a_long_series(self):\n    assertEqual(\n        slices(\"918493904243\", 5),\n        [\"91849\", \"18493\", \"84939\", \"49390\", \"93904\", \"39042\", \"90424\", \"04243\"],\n    )\n\ndef test_slice_length_is_too_large(self):\n    with pytest.raises(ValueError) as err:\n        slices(\"12345\", 6)\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0], \"slice length cannot be greater than series length\"\n    )\n\ndef test_slice_length_is_way_too_large(self):\n    with pytest.raises(ValueError) as err:\n        slices(\"12345\", 42)\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0], \"slice length cannot be greater than series length\"\n    )\n\ndef test_slice_length_cannot_be_zero(self):\n    with pytest.raises(ValueError) as err:\n        slices(\"12345\", 0)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"slice length cannot be zero\"\n\ndef test_slice_length_cannot_be_negative(self):\n    with pytest.raises(ValueError) as err:\n        slices(\"123\", -1)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"slice length cannot be negative\"\n\ndef test_empty_series_is_invalid(self):\n    with pytest.raises(ValueError) as err:\n        slices(\"\", 1)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"series cannot be empty\"\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.series import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for series\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/series.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}