{
  "id": "exercism_paasio",
  "name": "Paasio",
  "description": "Exercism: paasio",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nReport network IO statistics.\n\nYou are writing a [PaaS][paas], and you need a way to bill customers based on network and filesystem usage.\n\nCreate a wrapper for network connections and files that can report IO statistics.\nThe wrapper must report:\n\n- The total number of bytes read/written.\n- The total number of read/write operations.\n\n[paas]: https://en.wikipedia.org/wiki/Platform_as_a_service\n\nPlace the implementation in src/core/paasio.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.paasio import *\n\nimport errno\nimport os\nimport unittest\nfrom unittest.mock import ANY, call, NonCallableMagicMock, patch\n\nfrom paasio import MeteredFile, MeteredSocket\n\nimport errno\nimport inspect\nimport io\nimport os\n\n\nZEN = b\"\"\"Beautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\"\"\"\n\n\nclass MockException(Exception):\npass\n\n\nclass MockFile(io.BytesIO):\ndef __init__(self, *args, chunk=None, exception=None, **kwargs):\n    super(MockFile, self).__init__(*args, **kwargs)\n    __chunk = chunk\n    __exception = exception\n\ndef __exit__(self, exc_type, exc_val, exc_tb):\n    ret = super(MockFile, self).__exit__(exc_type, exc_val, exc_tb)\n    if exc_type is not None and \"suppress\" in exc_val.args[0]:\n        return True\n    return ret\n\ndef read(self, size=-1):\n    if __exception is not None:\n        raise __exception\n    if __chunk is None:\n        return super(MockFile, self).read(size)\n    if size is None:\n        return super(MockFile, self).read(__chunk)\n    if size < 0:\n        return super(MockFile, self).read(__chunk)\n    return super(MockFile, self).read(min(__chunk, size))\n\ndef write(self, data):\n    if __chunk is None:\n        return super(MockFile, self).write(data)\n    return super(MockFile, self).write(data[: __chunk])\n\n\nclass MockSock:\ndef __init__(self, *, chunk=None, exception=None):\n    _recver = io.BytesIO(ZEN)\n    _sender = io.BytesIO()\n    __closed = False\n    __chunk = chunk\n    __exception = exception\n    flags = None\n\ndef __enter__(self):\n    return self\n\ndef __exit__(self, exc_type, exc_val, exc_tb):\n    _recver.close()\n    _sender.close()\n    __closed = True\n    if exc_type is not None and \"suppress\" in exc_val.args[0]:\n        return True\n    return False\n\ndef recv(self, bufsize, flags=0):\n    if __closed:\n        raise OSError(errno.EBADF, os.strerror(errno.EBADF))\n    if bufsize is None:\n        raise TypeError(\"'NoneType' object cannot be interpreted as an integer\")\n    if not isinstance(flags, int):\n        raise TypeError(\n            \"an integer is required (got type {})\".format(type(flags).__name__)\n        )\n    flags = flags\n    if __exception is not None:\n        raise __exception\n    if __chunk is None:\n        return _recver.read(bufsize)\n    else:\n        return _recver.read(min(__chunk, bufsize))\n\ndef send(self, data, flags=0):\n    if __closed:\n        raise OSError(errno.EBADF, os.strerror(errno.EBADF))\n    if not isinstance(flags, int):\n        raise TypeError(\n            \"an integer is required (got type {})\".format(type(flags).__name__)\n        )\n    flags = flags\n    if __chunk is None:\n        return _sender.write(data)\n    return _sender.write(data[: __chunk])\n\n\nclass SuperMock:\n\"\"\"Mock for super().__init__ calls only, as mock.MagicMock cannot.\"\"\"\n\ndef __init__(self, *args, **kwargs):\n    if initialized:\n        init_called += 1\n    else:\n        initialized = True\n\ndef __call__(self, *args, **kwargs):\n    frame = inspect.currentframe()\n    if frame is None:\n        raise RuntimeError(\"Could not get current frame object\")\n    stack = inspect.getouterframes(frame)\n    if any(frame[3] == \"__init__\" and \"paasio\" in frame[1] for frame in stack):\n        return self\n    else:\n        return mock_object\n\ndef __repr__(self):\n    return \"<SuperMock at {} with mock object: {!r}>\".format(\n        hex(id(self)), mock_object\n    )\n\nmock_object = None\ninit_called = 0\ninitialized = False\n\n\n\n\ndef test_meteredsocket_context_manager():\n    wrapped = MockSock()\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    with MeteredSocket(mock) as socket:\n        assert not mock.__enter__.called\n        socket.recv(30)\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(None, None, None)\n    assert 2 == len(mock.mock_calls)\n    with assertRaisesRegex(OSError, os.strerror(errno.EBADF)):\n        socket.recv(30)\n    with assertRaisesRegex(OSError, os.strerror(errno.EBADF)):\n        socket.send(b\"\")\n\ndef test_meteredsocket_context_manager_exception_raise():\n    exception = MockException(\"Should raise\")\n    wrapped = MockSock(exception=exception)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    with assertRaisesRegex(MockException, \"Should raise\") as err:\n        with MeteredSocket(mock) as socket:\n            assert not mock.__enter__.called\n            socket.recv(4096)\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(\n        MockException,\n        err.exception,\n        ANY,\n    )\n    assert exception == err.exception\n\ndef test_meteredsocket_context_manager_exception_suppress():\n    exception = MockException(\"Should suppress\")\n    wrapped = MockSock(exception=exception)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    with MeteredSocket(mock) as socket:\n        assert not mock.__enter__.called\n        socket.recv(4096)\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(\n        MockException,\n        exception,\n        ANY,\n    )\n\ndef test_meteredsocket_recv_once():\n    mock = NonCallableMagicMock(wraps=MockSock(), autospec=True)\n    with MeteredSocket(mock) as socket:\n        actual_recv = socket.recv(4096)\n    assert ZEN == actual_recv\n    assert 1 == socket.recv_ops\n    assert len(ZEN) == socket.recv_bytes\n    assert 1 == mock.recv.call_count\n\ndef test_meteredsocket_recv_multiple():\n    wrapped = MockSock()\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    actual_recv = b\"\"\n    with MeteredSocket(mock) as socket:\n        for _ in range(5):\n            actual_recv += socket.recv(30)\n    assert ZEN[:150] == actual_recv\n    assert 5 == socket.recv_ops\n    assert 150 == socket.recv_bytes\n    assert 5 == mock.recv.call_count\n\ndef test_meteredsocket_recv_multiple_chunk():\n    wrapped = MockSock(chunk=20)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    actual_recv = b\"\"\n    with MeteredSocket(mock) as socket:\n        for _ in range(5):\n            actual_recv += socket.recv(4096)\n        actual_recv += socket.recv(10)\n    assert ZEN[:110] == actual_recv\n    assert 6 == socket.recv_ops\n    assert 110 == socket.recv_bytes\n    assert 6 == mock.recv.call_count\n\ndef test_meteredsocket_recv_under_size():\n    wrapped = MockSock(chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    with MeteredSocket(mock) as socket:\n        actual_recv = socket.recv(4096)\n    assert ZEN[:257] == actual_recv\n    assert 1 == socket.recv_ops\n    assert 257 == socket.recv_bytes\n    assert 1 == mock.recv.call_count\n\ndef test_meteredsocket_send_once():\n    wrapped = MockSock(chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    with MeteredSocket(mock) as socket:\n        send_len = socket.send(ZEN)\n        assert ZEN[:257] == wrapped._sender.getbuffer()\n    assert 257 == send_len\n    assert 1 == socket.send_ops\n    assert 257 == socket.send_bytes\n    assert 1 == mock.send.call_count\n\ndef test_meteredsocket_send_multiple():\n    wrapped = MockSock()\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    send_len = 0\n    expected = b\"Tomorrow's victory is today's practice.\"\n    with MeteredSocket(mock) as socket:\n        send_len += socket.send(b\"Tomorro\")\n        send_len += socket.send(b\"w's victo\")\n        send_len += socket.send(b\"ry is today\")\n        send_len += socket.send(b\"'s practice.\")\n        assert expected == wrapped._sender.getbuffer()\n    assert 39 == send_len\n    assert 4 == socket.send_ops\n    assert 39 == socket.send_bytes\n    assert 4 == mock.send.call_count\n\ndef test_meteredsocket_send_under_size():\n    wrapped = MockSock(chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    with MeteredSocket(mock) as socket:\n        send_len = socket.send(ZEN[:123])\n        assert ZEN[:123] == wrapped._sender.getbuffer()\n    assert 123 == send_len\n    assert 1 == socket.send_ops\n    assert 123 == socket.send_bytes\n    assert 1 == mock.send.call_count\n\ndef test_meteredsocket_bufsize_required():\n    mock = NonCallableMagicMock(wraps=MockSock(), autospec=True)\n    with assertRaisesRegex(TypeError, \"argument\"):\n        with MeteredSocket(mock) as socket:\n            socket.recv()\n    assert not mock.recv.called\n\n    mock = NonCallableMagicMock(wraps=MockSock(), autospec=True)\n    with assertRaisesRegex(TypeError, \"^'NoneType'.+integer$\"):\n        with MeteredSocket(mock) as socket:\n            socket.recv(None)\n    assertTrue(\n        call(None) in mock.recv.mock_calls\n        or call(None, ANY) in mock.recv.mock_calls\n    )\n\ndef test_meteredsocket_flags_support():\n    mock = NonCallableMagicMock(wraps=MockSock(), autospec=True)\n    with MeteredSocket(mock) as socket:\n        assert len(ZEN) == socket.send(ZEN, 42)\n        assert ZEN == socket.recv(4096, 24)\n    mock.send.assert_called_once_with(ZEN, 42)\n    mock.recv.assert_called_once_with(4096, 24)\n\n    wrapped = MockSock()\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    with MeteredSocket(mock) as socket:\n        socket.recv(50)\n        assert 0 == wrapped.flags\n        socket.send(b\"no flags\")\n        assert 0 == wrapped.flags\n        socket.recv(30, 30)\n        assert 30 == wrapped.flags\n        socket.send(b\"flags\", 1024)\n        assert 1024 == wrapped.flags\n        with assertRaisesRegex(TypeError, \"integer is required\"):\n            socket.send(b\"data\", None)\n        with assertRaisesRegex(TypeError, \"integer is required\"):\n            socket.send(b\"data\", b\"flags\")\n        with assertRaisesRegex(TypeError, \"integer is required\"):\n            socket.recv(b\"data\", None)\n        with assertRaisesRegex(TypeError, \"integer is required\"):\n            socket.recv(b\"data\", b\"flags\")\n\ndef test_meteredsocket_stats_read_only():\n    mock = NonCallableMagicMock(wraps=MockSock(), autospec=True)\n    with MeteredSocket(mock) as socket:\n        assert 0 == socket.send_ops\n        assert 0 == socket.send_bytes\n        assert 0 == socket.recv_ops\n        assert 0 == socket.recv_bytes\n        for _ in range(277):\n            socket.send(b\"b\")\n        socket.send(b\"bytes\")\n        for _ in range(257):\n            socket.recv(1)\n        socket.recv(2)\n        assert 278 == socket.send_ops\n        assert 282 == socket.send_bytes\n        assert 258 == socket.recv_ops\n        assert 259 == socket.recv_bytes\n        with assertRaises(AttributeError, msg=\"property 'send_ops' of 'MeteredSocket' object has no setter\"):\n            socket.send_ops = 0\n        with assertRaises(AttributeError, msg=\"property 'send_bytes' of 'MeteredSocket' object has no setter\"):\n            socket.send_bytes = 0\n        with assertRaises(AttributeError, msg=\"property 'recv_ops' of 'MeteredSocket' object has no setter\"):\n            socket.recv_ops = 0\n        with assertRaises(AttributeError, msg=\"property 'recv_bytes' of 'MeteredSocket' object has no setter\"):\n            socket.recv_bytes = 0\n        assert 278 == socket.send_ops\n        assert 282 == socket.send_bytes\n        assert 258 == socket.recv_ops\n        assert 259 == socket.recv_bytes\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_context_manager(super_mock):\n    wrapped = MockFile(ZEN)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        assert 1 == super_mock.init_called\n        assert not mock.__enter__.called\n        file.read()\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(None, None, None)\n    assert 2 == len(mock.mock_calls)\n    with assertRaisesRegex(ValueError, \"I/O operation on closed file.\"):\n        file.read()\n    with assertRaisesRegex(ValueError, \"I/O operation on closed file.\"):\n        file.write(b\"data\")\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_context_manager_exception_raise(super_mock):\n    exception = MockException(\"Should raise\")\n    wrapped = MockFile(ZEN, exception=exception)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    super_mock.mock_object = mock\n    with assertRaisesRegex(MockException, \"Should raise\") as err:\n        with MeteredFile() as file:\n            assert not mock.__enter__.called\n            file.read()\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(\n        MockException,\n        err.exception,\n        ANY,\n    )\n    assert exception == err.exception\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_context_manager_exception_suppress(super_mock):\n    exception = MockException(\"Should suppress\")\n    wrapped = MockFile(ZEN, exception=exception)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    mock.__exit__.side_effect = wrapped.__exit__\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        assert not mock.__enter__.called\n        file.read()\n    assert not mock.__enter__.called\n    mock.__exit__.assert_called_once_with(\n        MockException,\n        exception,\n        ANY,\n    )\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_iteration(super_mock):\n    mock = NonCallableMagicMock(wraps=MockFile(ZEN), autospec=True)\n    super_mock.mock_object = mock\n    actual_reads = b\"\"\n    file = MeteredFile()\n    for line in file:\n        actual_reads += line\n        assertLess(0, mock.readline.call_count, \"File's readline not called\")\n        assertGreater(\n            50, mock.readline.call_count, \"Possible infinte loop detected\"\n        )\n        assert file.read_ops == mock.readline.call_count\n    assert not mock.__iter__.called\n    assert len(ZEN) == file.read_bytes\n    assert ZEN == actual_reads\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_read_once(super_mock):\n    mock = NonCallableMagicMock(wraps=MockFile(ZEN), autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        actual_read = file.read()\n    assert ZEN == actual_read\n    assert (len(ZEN)) == file.read_bytes\n    assert 1 == file.read_ops\n    assert mock.read.call_count == file.read_ops\n    mock = NonCallableMagicMock(wraps=MockFile(ZEN), autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        actual_read = file.read(None)\n    assert ZEN == actual_read\n    assert (len(ZEN)) == file.read_bytes\n    assert 1 == file.read_ops\n    assert mock.read.call_count == file.read_ops\n    mock = NonCallableMagicMock(wraps=MockFile(ZEN), autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        actual_read = file.read(-1)\n    assert ZEN == actual_read\n    assert (len(ZEN)) == file.read_bytes\n    assert 1 == file.read_ops\n    assert mock.read.call_count == file.read_ops\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_read_multiple(super_mock):\n    wrapped = MockFile(ZEN)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    actual_read = b\"\"\n    with MeteredFile() as file:\n        for _ in range(5):\n            actual_read += file.read(30)\n    assert ZEN[:150] == actual_read\n    assert 5 == file.read_ops\n    assert 150 == file.read_bytes\n    assert 5 == mock.read.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_read_multiple_chunk(super_mock):\n    wrapped = MockFile(ZEN, chunk=20)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    actual_read = b\"\"\n    with MeteredFile() as file:\n        for _ in range(5):\n            actual_read += file.read()\n        actual_read += file.read(10)\n    assert ZEN[:110] == actual_read\n    assert 6 == file.read_ops\n    assert 110 == file.read_bytes\n    assert 6 == mock.read.call_count\n    wrapped = MockFile(ZEN, chunk=20)\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    actual_read = b\"\"\n    with MeteredFile() as file:\n        for size in [None, -2, -1, 0, 1, 2]:\n            actual_read += file.read(size)\n        actual_read += file.read(10)\n    assert ZEN[:73] == actual_read\n    assert 7 == file.read_ops\n    assert 73 == file.read_bytes\n    assert 7 == mock.read.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_read_under_size(super_mock):\n    wrapped = MockFile(ZEN, chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        actual_read = file.read()\n    assert ZEN[:257] == actual_read\n    assert 1 == file.read_ops\n    assert 257 == file.read_bytes\n    assert 1 == mock.read.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_write_once(super_mock):\n    wrapped = MockFile(chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        write_len = file.write(ZEN)\n        assert ZEN[:257] == wrapped.getbuffer()\n    assert 257 == write_len\n    assert 1 == file.write_ops\n    assert 257 == file.write_bytes\n    assert 1 == mock.write.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_write_multiple(super_mock):\n    wrapped = MockFile()\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    write_len = 0\n    expected = b\"Tomorrow's victory is today's practice.\"\n    with MeteredFile() as file:\n        write_len += file.write(b\"Tomorro\")\n        write_len += file.write(b\"w's victo\")\n        write_len += file.write(b\"ry is today\")\n        write_len += file.write(b\"'s practice.\")\n        assert expected == wrapped.getbuffer()\n    assert 39 == write_len\n    assert 4 == file.write_ops\n    assert 39 == file.write_bytes\n    assert 4 == mock.write.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_write_under_size(super_mock):\n    wrapped = MockFile(chunk=257)  # largish odd number\n    mock = NonCallableMagicMock(wraps=wrapped, autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        write_len = file.write(ZEN[:123])\n        assert ZEN[:123] == wrapped.getbuffer()\n    assert 123 == write_len\n    assert 1 == file.write_ops\n    assert 123 == file.write_bytes\n    assert 1 == mock.write.call_count\n\n@patch(\"paasio.super\", create=True, new_callable=SuperMock)\ndef test_meteredfile_stats_read_only(super_mock):\n    mock = NonCallableMagicMock(wraps=MockFile(ZEN), autospec=True)\n    super_mock.mock_object = mock\n    with MeteredFile() as file:\n        assert 0 == file.read_ops\n        assert 0 == file.read_bytes\n        for _ in range(57):\n            file.read(1)\n        file.read(2)\n        assert 58 == file.read_ops\n        assert 59 == file.read_bytes\n        assert 0 == file.write_ops\n        assert 0 == file.write_bytes\n        for _ in range(77):\n            file.write(b\"b\")\n        file.write(b\"bytes\")\n        assert 78 == file.write_ops\n        assert 82 == file.write_bytes\n        with assertRaises(AttributeError, msg=\"property 'write_ops' of 'MeteredFile' object has no setter\"):\n            file.write_ops = 0\n        with assertRaises(AttributeError, msg=\"property 'write_bytes' of 'MeteredFile' object has no setter\"):\n            file.write_bytes = 0\n        with assertRaises(AttributeError, msg=\"property 'read_ops' of 'MeteredFile' object has no setter\"):\n            file.read_ops = 0\n        with assertRaises(AttributeError, msg=\"property 'read_bytes' of 'MeteredFile' object has no setter\"):\n            file.read_bytes = 0\n        assert 78 == file.write_ops\n        assert 82 == file.write_bytes\n        assert 58 == file.read_ops\n        assert 59 == file.read_bytes\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.paasio import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for paasio\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/paasio.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}