{
  "id": "exercism_point_mutations",
  "name": "Point Mutations",
  "description": "Exercism: point_mutations",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nCalculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n## Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. Hence you\nmay assume that only sequences of equal length will be passed to your hamming\ndistance function.\n\n**Note: This problem is deprecated, replaced by the one called `hamming`.**\n\nPlace the implementation in src/core/point_mutations.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.point_mutations import *\n\nimport unittest\n\nfrom point_mutations import hamming_distance\n\n\n\ndef test_no_difference_between_empty_strands():\n    assert hamming_distance('' == '', 0)\n\ndef test_no_difference_between_identical_strands():\n    assert hamming_distance('GGACTGA' == 'GGACTGA', 0)\n\ndef test_complete_hamming_distance_in_small_strand():\n    assert hamming_distance('ACT' == 'GGA', 3)\n\ndef test_hamming_distance_in_off_by_one_strand():\n    assertEqual(\n        hamming_distance('GGACGGATTCTGACCTGGACTAATTTTGGGG',\n                         'AGGACGGATTCTGACCTGGACTAATTTTGGGG'), 19)\n\ndef test_small_hamming_distance_in_middle_somewhere():\n    assert hamming_distance('GGACG' == 'GGTCG', 1)\n\ndef test_larger_distance():\n    assert hamming_distance('ACCAGGG' == 'ACTATGG', 2)\n\ndef test_ignores_extra_length_on_other_strand_when_longer():\n    assert hamming_distance('AAACTAGGGG' == 'AGGCTAGCGGTAGGAC', 3)\n\ndef test_ignores_extra_length_on_original_strand_when_longer():\n    assertEqual(\n        hamming_distance('GACTACGGACAGGGTAGGGAAT', 'GACATCGCACACC'), 5)\n\n\nif __name__ == '__main__':\nunittest.main()\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.point_mutations import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for point_mutations\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/point_mutations.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "medium"
}