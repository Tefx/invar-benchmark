{
  "id": "exercism_tree_building",
  "name": "Tree Building",
  "description": "Exercism: tree_building",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nRefactor a tree building algorithm.\n\nSome web-forums have a tree layout, so posts are presented as a tree.\nHowever the posts are typically stored in a database as an unsorted set of records.\nThus when presenting the posts to the user the tree structure has to be reconstructed.\n\nYour job will be to refactor a working but slow and ugly piece of code that implements the tree building logic for highly abstracted records.\nThe records only contain an ID number and a parent ID number.\nThe ID number is always between 0 (inclusive) and the length of the record list (exclusive).\nAll records have a parent ID lower than their own ID, except for the root record, which has a parent ID that's equal to its own ID.\n\nAn example tree:\n\n```text\nroot (ID: 0, parent ID: 0)\n|-- child1 (ID: 1, parent ID: 0)\n|    |-- grandchild1 (ID: 2, parent ID: 1)\n|    +-- grandchild2 (ID: 4, parent ID: 1)\n+-- child2 (ID: 3, parent ID: 0)\n|    +-- grandchild3 (ID: 6, parent ID: 3)\n+-- child3 (ID: 5, parent ID: 0)\n```\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you refactor how/where the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) is used to \"throw\" a `ValueError` for invalid tree input. The tests will only pass if the code both `raise`s the appropriate `exception` and includes an appropriate message with it.\n\nPlace the implementation in src/core/tree_building.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.tree_building import *\n\nimport unittest\n\nfrom tree_building import Record, BuildTree\n\n\n\n\"\"\"\n    Record(record_id, parent_id): records given to be processed\n    Node(node_id): Node in tree\n    BuildTree(records): records as argument and returns tree\n    BuildTree should raise ValueError if given records are invalid\n\"\"\"\n\ndef test_empty_list_input():\n    records = []\n    root = BuildTree(records)\n    assertIsNone(root)\n\ndef test_one_node():\n    records = [\n        Record(0, 0)\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_leaf(root, node_id=0)\n\ndef test_three_nodes_in_order():\n    records = [\n        Record(0, 0),\n        Record(1, 0),\n        Record(2, 0)\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_branch(root, node_id=0, children_count=2)\n    assert_node_is_leaf(root.children[0], node_id=1)\n    assert_node_is_leaf(root.children[1], node_id=2)\n\ndef test_three_nodes_in_reverse_order():\n    records = [\n        Record(2, 0),\n        Record(1, 0),\n        Record(0, 0)\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_branch(root, node_id=0, children_count=2)\n    assert_node_is_leaf(root.children[0], node_id=1)\n    assert_node_is_leaf(root.children[1], node_id=2)\n\ndef test_more_than_two_children():\n    records = [\n        Record(0, 0),\n        Record(1, 0),\n        Record(2, 0),\n        Record(3, 0)\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_branch(root, node_id=0, children_count=3)\n    assert_node_is_leaf(root.children[0], node_id=1)\n    assert_node_is_leaf(root.children[1], node_id=2)\n    assert_node_is_leaf(root.children[2], node_id=3)\n\ndef test_binary_tree():\n    records = [\n        Record(6, 2),\n        Record(0, 0),\n        Record(3, 1),\n        Record(2, 0),\n        Record(4, 1),\n        Record(5, 2),\n        Record(1, 0)\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_branch(root, 0, 2)\n    assert_node_is_branch(root.children[0], 1, 2)\n    assert_node_is_branch(root.children[1], 2, 2)\n    assert_node_is_leaf(root.children[0].children[0], 3)\n    assert_node_is_leaf(root.children[0].children[1], 4)\n    assert_node_is_leaf(root.children[1].children[0], 5)\n    assert_node_is_leaf(root.children[1].children[1], 6)\n\ndef test_unbalanced_tree():\n    records = [\n        Record(0, 0),\n        Record(1, 0),\n        Record(2, 0),\n        Record(3, 1),\n        Record(4, 1),\n        Record(5, 1),\n        Record(6, 2),\n    ]\n    root = BuildTree(records)\n\n    assert_node_is_branch(root, 0, 2)\n    assert_node_is_branch(root.children[0], 1, 3)\n    assert_node_is_branch(root.children[1], 2, 1)\n    assert_node_is_leaf(root.children[0].children[0], 3)\n    assert_node_is_leaf(root.children[0].children[1], 4)\n    assert_node_is_leaf(root.children[0].children[2], 5)\n    assert_node_is_leaf(root.children[1].children[0], 6)\n\ndef test_root_node_has_parent():\n    records = [\n        Record(0, 1),\n        Record(1, 0)\n    ]\n    # Root parent_id should be equal to record_id(0)\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Node parent_id should be smaller than it's record_id.\"\n\ndef test_no_root_node():\n    records = [\n        Record(1, 0),\n        Record(2, 0)\n    ]\n    # Record with record_id 0 (root) is missing\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Record id is invalid or out of order.\"\n\ndef test_non_continuous():\n    records = [\n        Record(2, 0),\n        Record(4, 2),\n        Record(1, 0),\n        Record(0, 0)\n    ]\n    # Record with record_id 3 is missing\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Record id is invalid or out of order.\"\n\ndef test_cycle_directly():\n    records = [\n        Record(5, 2),\n        Record(3, 2),\n        Record(2, 2),\n        Record(4, 1),\n        Record(1, 0),\n        Record(0, 0),\n        Record(6, 3)\n    ]\n    # Cycle caused by Record 2 with parent_id pointing to itself\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Only root should have equal record and parent id.\"\n\ndef test_cycle_indirectly():\n    records = [\n        Record(5, 2),\n        Record(3, 2),\n        Record(2, 6),\n        Record(4, 1),\n        Record(1, 0),\n        Record(0, 0),\n        Record(6, 3)\n    ]\n    # Cycle caused by Record 2 with parent_id(6) greater than record_id(2)\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Node parent_id should be smaller than it's record_id.\"\n\ndef test_higher_id_parent_of_lower_id():\n    records = [\n        Record(0, 0),\n        Record(2, 0),\n        Record(1, 2)\n    ]\n    # Record 1 have parent_id(2) greater than record_id(1)\n    with pytest.raises(ValueError) as err:\n        BuildTree(records)\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"Node parent_id should be smaller than it's record_id.\"\n\ndef assert_node_is_branch(self, node, node_id, children_count):\n    assert node.node_id == node_id\n    assertNotEqual(len(node.children), 0)\n    assert len(node.children) == children_count\n\ndef assert_node_is_leaf(self, node, node_id):\n    assert node.node_id == node_id\n    assert len(node.children) == 0\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.tree_building import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for tree_building\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/tree_building.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}