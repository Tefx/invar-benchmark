{
  "id": "exercism_react",
  "name": "React",
  "description": "Exercism: react",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nImplement a basic reactive system.\n\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\n\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\n\nIn addition, compute cells should allow for registering change notification callbacks.\nCall a cell\u2019s callbacks when the cell\u2019s value in a new stable state has changed from the previous stable state.\n\nPlace the implementation in src/core/react.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.react import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/react/canonical-data.json\n# File last updated on 2023-07-19\n\nfrom functools import partial\nimport unittest\n\nfrom react import (\nInputCell,\nComputeCell,\n)\n\n\n\ndef test_input_cells_have_a_value():\n    input = InputCell(10)\n    assert input.value == 10\n\ndef test_an_input_cell_s_value_can_be_set():\n    input = InputCell(4)\n    input.value = 20\n    assert input.value == 20\n\ndef test_compute_cells_calculate_initial_value():\n    input = InputCell(1)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    assert output.value == 2\n\ndef test_compute_cells_take_inputs_in_the_right_order():\n    one = InputCell(1)\n    two = InputCell(2)\n    output = ComputeCell(\n        [\n            one,\n            two,\n        ],\n        lambda inputs: inputs[0] + inputs[1] * 10,\n    )\n    assert output.value == 21\n\ndef test_compute_cells_update_value_when_dependencies_are_changed():\n    input = InputCell(1)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    input.value = 3\n    assert output.value == 4\n\ndef test_compute_cells_can_depend_on_other_compute_cells():\n    input = InputCell(1)\n    times_two = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] * 2,\n    )\n    times_thirty = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] * 30,\n    )\n    output = ComputeCell(\n        [\n            times_two,\n            times_thirty,\n        ],\n        lambda inputs: inputs[0] + inputs[1],\n    )\n    assert output.value == 32\n    input.value = 3\n    assert output.value == 96\n\ndef test_compute_cells_fire_callbacks():\n    input = InputCell(1)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    cb1_observer = []\n    callback1 = callback_factory(cb1_observer)\n    output.add_callback(callback1)\n    input.value = 3\n    assert cb1_observer[-1] == 4\n\ndef test_callback_cells_only_fire_on_change():\n    input = InputCell(1)\n    output = ComputeCell([input], lambda inputs: 111 if inputs[0] < 3 else 222)\n    cb1_observer = []\n    callback1 = callback_factory(cb1_observer)\n    output.add_callback(callback1)\n    input.value = 2\n    assert cb1_observer == []\n    input.value = 4\n    assert cb1_observer[-1] == 222\n\ndef test_callbacks_do_not_report_already_reported_values():\n    input = InputCell(1)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    cb1_observer = []\n    callback1 = callback_factory(cb1_observer)\n    output.add_callback(callback1)\n    input.value = 2\n    assert cb1_observer[-1] == 3\n    input.value = 3\n    assert cb1_observer[-1] == 4\n\ndef test_callbacks_can_fire_from_multiple_cells():\n    input = InputCell(1)\n    plus_one = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    minus_one = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] - 1,\n    )\n    cb1_observer = []\n    cb2_observer = []\n    callback1 = callback_factory(cb1_observer)\n    callback2 = callback_factory(cb2_observer)\n    plus_one.add_callback(callback1)\n    minus_one.add_callback(callback2)\n    input.value = 10\n    assert cb1_observer[-1] == 11\n    assert cb2_observer[-1] == 9\n\ndef test_callbacks_can_be_added_and_removed():\n    input = InputCell(11)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    cb1_observer = []\n    cb2_observer = []\n    cb3_observer = []\n    callback1 = callback_factory(cb1_observer)\n    callback2 = callback_factory(cb2_observer)\n    callback3 = callback_factory(cb3_observer)\n    output.add_callback(callback1)\n    output.add_callback(callback2)\n    input.value = 31\n    assert cb1_observer[-1] == 32\n    assert cb2_observer[-1] == 32\n    output.remove_callback(callback1)\n    output.add_callback(callback3)\n    input.value = 41\n    assert len(cb1_observer) == 1\n    assert cb2_observer[-1] == 42\n    assert cb3_observer[-1] == 42\n\ndef test_removing_a_callback_multiple_times_doesn_t_interfere_with_other_callbacks(\n    self,\n):\n    input = InputCell(1)\n    output = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    cb1_observer = []\n    cb2_observer = []\n    callback1 = callback_factory(cb1_observer)\n    callback2 = callback_factory(cb2_observer)\n    output.add_callback(callback1)\n    output.add_callback(callback2)\n    output.remove_callback(callback1)\n    output.remove_callback(callback1)\n    output.remove_callback(callback1)\n    input.value = 2\n    assert cb1_observer == []\n    assert cb2_observer[-1] == 3\n\ndef test_callbacks_should_only_be_called_once_even_if_multiple_dependencies_change(\n    self,\n):\n    input = InputCell(1)\n    plus_one = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    minus_one1 = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] - 1,\n    )\n    minus_one2 = ComputeCell(\n        [\n            minus_one1,\n        ],\n        lambda inputs: inputs[0] - 1,\n    )\n    output = ComputeCell(\n        [\n            plus_one,\n            minus_one2,\n        ],\n        lambda inputs: inputs[0] * inputs[1],\n    )\n    cb1_observer = []\n    callback1 = callback_factory(cb1_observer)\n    output.add_callback(callback1)\n    input.value = 4\n    assert cb1_observer[-1] == 10\n\ndef test_callbacks_should_not_be_called_if_dependencies_change_but_output_value_doesn_t_change(\n    self,\n):\n    input = InputCell(1)\n    plus_one = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] + 1,\n    )\n    minus_one = ComputeCell(\n        [\n            input,\n        ],\n        lambda inputs: inputs[0] - 1,\n    )\n    always_two = ComputeCell(\n        [\n            plus_one,\n            minus_one,\n        ],\n        lambda inputs: inputs[0] - inputs[1],\n    )\n    cb1_observer = []\n    callback1 = callback_factory(cb1_observer)\n    always_two.add_callback(callback1)\n    input.value = 2\n    assert cb1_observer == []\n    input.value = 3\n    assert cb1_observer == []\n    input.value = 4\n    assert cb1_observer == []\n    input.value = 5\n    assert cb1_observer == []\n\n# Utility functions.\ndef callback_factory(self, observer):\n    def callback(observer, value):\n        observer.append(value)\n\n    return partial(callback, observer)\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.react import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for react\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/react.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}