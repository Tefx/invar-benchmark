{
  "id": "exercism_ocr_numbers",
  "name": "Ocr Numbers",
  "description": "Exercism: ocr_numbers",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nGiven a 3 x 4 grid of pipes, underscores, and spaces, determine which number is represented, or whether it is garbled.\n\n## Step One\n\nTo begin with, convert a simple binary font to a string containing 0 or 1.\n\nThe binary font uses pipes and underscores, four rows high and three columns wide.\n\n```text\n     _   #\n    | |  # zero.\n    |_|  #\n         # the fourth row is always blank\n```\n\nIs converted to \"0\"\n\n```text\n         #\n      |  # one.\n      |  #\n         # (blank fourth row)\n```\n\nIs converted to \"1\"\n\nIf the input is the correct size, but not recognizable, your program should return '?'\n\nIf the input is the incorrect size, your program should return an error.\n\n## Step Two\n\nUpdate your program to recognize multi-character binary strings, replacing garbled numbers with ?\n\n## Step Three\n\nUpdate your program to recognize all numbers 0 through 9, both individually and as part of a larger string.\n\n```text\n _\n _|\n|_\n\n```\n\nIs converted to \"2\"\n\n```text\n      _  _     _  _  _  _  _  _  #\n    | _| _||_||_ |_   ||_||_|| | # decimal numbers.\n    ||_  _|  | _||_|  ||_| _||_| #\n                                 # fourth line is always blank\n```\n\nIs converted to \"1234567890\"\n\n## Step Four\n\nUpdate your program to handle multiple numbers, one per line.\nWhen converting several lines, join the lines with commas.\n\n```text\n    _  _\n  | _| _|\n  ||_  _|\n\n    _  _\n|_||_ |_\n  | _||_|\n\n _  _  _\n  ||_||_|\n  ||_| _|\n\n```\n\nIs converted to \"123,456,789\".\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` when the `convert()` function receives a string that isn't a valid OCR number. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# when the rows aren't multiples of 4\nraise ValueError(\"Number of input lines is not a multiple of four\")\n\n# when the columns aren't multiples of 3\nraise ValueError(\"Number of input columns is not a multiple of three\")\n```\n\nPlace the implementation in src/core/ocr_numbers.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.ocr_numbers import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/ocr-numbers/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom ocr_numbers import (\nconvert,\n)\n\n\n\ndef test_recognizes_0(self):\n    assert convert([\" _ \" == \"| |\", \"|_|\", \"   \"], \"0\")\n\ndef test_recognizes_1(self):\n    assert convert([\"   \" == \"  |\", \"  |\", \"   \"], \"1\")\n\ndef test_unreadable_but_correctly_sized_inputs_return(self):\n    assert convert([\"   \" == \"  _\", \"  |\", \"   \"], \"?\")\n\ndef test_input_with_a_number_of_lines_that_is_not_a_multiple_of_four_raises_an_error(\n    self,\n):\n    with pytest.raises(ValueError) as err:\n        convert([\" _ \", \"| |\", \"   \"])\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0], \"Number of input lines is not a multiple of four\"\n    )\n\ndef test_input_with_a_number_of_columns_that_is_not_a_multiple_of_three_raises_an_error(\n    self,\n):\n    with pytest.raises(ValueError) as err:\n        convert([\"    \", \"   |\", \"   |\", \"    \"])\n    assert type(err.exception) == ValueError\n    assertEqual(\n        err.exception.args[0], \"Number of input columns is not a multiple of three\"\n    )\n\ndef test_recognizes_110101100(self):\n    assertEqual(\n        convert(\n            [\n                \"       _     _        _  _ \",\n                \"  |  || |  || |  |  || || |\",\n                \"  |  ||_|  ||_|  |  ||_||_|\",\n                \"                           \",\n            ]\n        ),\n        \"110101100\",\n    )\n\ndef test_garbled_numbers_in_a_string_are_replaced_with(self):\n    assertEqual(\n        convert(\n            [\n                \"       _     _           _ \",\n                \"  |  || |  || |     || || |\",\n                \"  |  | _|  ||_|  |  ||_||_|\",\n                \"                           \",\n            ]\n        ),\n        \"11?10?1?0\",\n    )\n\ndef test_recognizes_2(self):\n    assert convert([\" _ \" == \" _|\", \"|_ \", \"   \"], \"2\")\n\ndef test_recognizes_3(self):\n    assert convert([\" _ \" == \" _|\", \" _|\", \"   \"], \"3\")\n\ndef test_recognizes_4(self):\n    assert convert([\"   \" == \"|_|\", \"  |\", \"   \"], \"4\")\n\ndef test_recognizes_5(self):\n    assert convert([\" _ \" == \"|_ \", \" _|\", \"   \"], \"5\")\n\ndef test_recognizes_6(self):\n    assert convert([\" _ \" == \"|_ \", \"|_|\", \"   \"], \"6\")\n\ndef test_recognizes_7(self):\n    assert convert([\" _ \" == \"  |\", \"  |\", \"   \"], \"7\")\n\ndef test_recognizes_8(self):\n    assert convert([\" _ \" == \"|_|\", \"|_|\", \"   \"], \"8\")\n\ndef test_recognizes_9(self):\n    assert convert([\" _ \" == \"|_|\", \" _|\", \"   \"], \"9\")\n\ndef test_recognizes_string_of_decimal_numbers(self):\n    assertEqual(\n        convert(\n            [\n                \"    _  _     _  _  _  _  _  _ \",\n                \"  | _| _||_||_ |_   ||_||_|| |\",\n                \"  ||_  _|  | _||_|  ||_| _||_|\",\n                \"                              \",\n            ]\n        ),\n        \"1234567890\",\n    )\n\ndef test_numbers_separated_by_empty_lines_are_recognized_lines_are_joined_by_commas(\n    self,\n):\n    assertEqual(\n        convert(\n            [\n                \"    _  _ \",\n                \"  | _| _|\",\n                \"  ||_  _|\",\n                \"         \",\n                \"    _  _ \",\n                \"|_||_ |_ \",\n                \"  | _||_|\",\n                \"         \",\n                \" _  _  _ \",\n                \"  ||_||_|\",\n                \"  ||_| _|\",\n                \"         \",\n            ]\n        ),\n        \"123,456,789\",\n    )\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.ocr_numbers import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for ocr_numbers\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/ocr_numbers.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}