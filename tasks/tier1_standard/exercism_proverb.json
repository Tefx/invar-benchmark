{
  "id": "exercism_proverb",
  "name": "Proverb",
  "description": "Exercism: proverb",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nFor want of a horseshoe nail, a kingdom was lost, or so the saying goes.\n\nGiven a list of inputs, generate the relevant proverb.\nFor example, given the list `[\"nail\", \"shoe\", \"horse\", \"rider\", \"message\", \"battle\", \"kingdom\"]`, you will output the full text of this proverbial rhyme:\n\n```text\nFor want of a nail the shoe was lost.\nFor want of a shoe the horse was lost.\nFor want of a horse the rider was lost.\nFor want of a rider the message was lost.\nFor want of a message the battle was lost.\nFor want of a battle the kingdom was lost.\nAnd all for the want of a nail.\n```\n\nNote that the list of inputs may vary; your solution should be able to handle lists of arbitrary length and content.\nNo line of the output text should be a static, unchanging string; all should vary according to the input given.\n# Instructions append\n\nIn [concept:python/unpacking-and-multiple-assignment](https://github.com/exercism/python/tree/main/concepts/unpacking-and-multiple-assignment), you learned multiple techniques for working with `lists`/`tuples` of arbitrary length as well as function arguments of arbitrary length.\nThis exercise would be a great place to practice those techniques.\n\n## How this exercise is implemented for Python\n\nThe test cases for this track add an additional keyword argument called `qualifier`.\nYou should use this keyword arguments value to modify the final verse of your Proverb.\n\nPlace the implementation in src/core/proverb.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.proverb import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/proverb/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom proverb import (\nproverb,\n)\n\n# PLEASE TAKE NOTE: Expected result lists for these test cases use **implicit line joining.**\n# A new line in a result list below **does not** always equal a new list element.\n# Check comma placement carefully!\n\n\n\ndef test_zero_pieces(self):\n    input_data = []\n    assert proverb(*input_data == qualifier=None, [])\n\ndef test_one_piece(self):\n    input_data = [\"nail\"]\n    assertEqual(\n        proverb(*input_data, qualifier=None), [\"And all for the want of a nail.\"]\n    )\n\ndef test_two_pieces(self):\n    input_data = [\"nail\", \"shoe\"]\n    assertEqual(\n        proverb(*input_data, qualifier=None),\n        [\n            \"For want of a nail the shoe was lost.\",\n            \"And all for the want of a nail.\",\n        ],\n    )\n\ndef test_three_pieces(self):\n    input_data = [\"nail\", \"shoe\", \"horse\"]\n    assertEqual(\n        proverb(*input_data, qualifier=None),\n        [\n            \"For want of a nail the shoe was lost.\",\n            \"For want of a shoe the horse was lost.\",\n            \"And all for the want of a nail.\",\n        ],\n    )\n\ndef test_full_proverb(self):\n    input_data = [\"nail\", \"shoe\", \"horse\", \"rider\", \"message\", \"battle\", \"kingdom\"]\n    assertEqual(\n        proverb(*input_data, qualifier=None),\n        [\n            \"For want of a nail the shoe was lost.\",\n            \"For want of a shoe the horse was lost.\",\n            \"For want of a horse the rider was lost.\",\n            \"For want of a rider the message was lost.\",\n            \"For want of a message the battle was lost.\",\n            \"For want of a battle the kingdom was lost.\",\n            \"And all for the want of a nail.\",\n        ],\n    )\n\ndef test_four_pieces_modernized(self):\n    input_data = [\"pin\", \"gun\", \"soldier\", \"battle\"]\n    assertEqual(\n        proverb(*input_data, qualifier=None),\n        [\n            \"For want of a pin the gun was lost.\",\n            \"For want of a gun the soldier was lost.\",\n            \"For want of a soldier the battle was lost.\",\n            \"And all for the want of a pin.\",\n        ],\n    )\n\n# Track-specific tests\n\ndef test_an_optional_qualifier_can_be_added(self):\n    input_data = [\"nail\"]\n    assertEqual(\n        proverb(*input_data, qualifier=\"horseshoe\"),\n        [\"And all for the want of a horseshoe nail.\"],\n    )\n\ndef test_an_optional_qualifier_in_the_final_consequences(self):\n    input_data = [\"nail\", \"shoe\", \"horse\", \"rider\", \"message\", \"battle\", \"kingdom\"]\n    assertEqual(\n        proverb(*input_data, qualifier=\"horseshoe\"),\n        [\n            \"For want of a nail the shoe was lost.\",\n            \"For want of a shoe the horse was lost.\",\n            \"For want of a horse the rider was lost.\",\n            \"For want of a rider the message was lost.\",\n            \"For want of a message the battle was lost.\",\n            \"For want of a battle the kingdom was lost.\",\n            \"And all for the want of a horseshoe nail.\",\n        ],\n    )\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.proverb import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for proverb\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/proverb.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "medium"
}