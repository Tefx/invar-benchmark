{
  "id": "exercism_variable_length_quantity",
  "name": "Variable Length Quantity",
  "description": "Exercism: variable_length_quantity",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nImplement variable length quantity encoding and decoding.\n\nThe goal of this exercise is to implement [VLQ][vlq] encoding/decoding.\n\nIn short, the goal of this encoding is to encode integer values in a way that would save bytes.\nOnly the first 7 bits of each byte are significant (right-justified; sort of like an ASCII byte).\nSo, if you have a 32-bit value, you have to unpack it into a series of 7-bit bytes.\nOf course, you will have a variable number of bytes depending upon your integer.\nTo indicate which is the last byte of the series, you leave bit #7 clear.\nIn all of the preceding bytes, you set bit #7.\n\nSo, if an integer is between `0-127`, it can be represented as one byte.\nAlthough VLQ can deal with numbers of arbitrary sizes, for this exercise we will restrict ourselves to only numbers that fit in a 32-bit unsigned integer.\nHere are examples of integers as 32-bit values, and the variable length quantities that they translate to:\n\n```text\n NUMBER        VARIABLE QUANTITY\n00000000              00\n00000040              40\n0000007F              7F\n00000080             81 00\n00002000             C0 00\n00003FFF             FF 7F\n00004000           81 80 00\n00100000           C0 80 00\n001FFFFF           FF FF 7F\n00200000          81 80 80 00\n08000000          C0 80 80 00\n0FFFFFFF          FF FF FF 7F\n```\n\n[vlq]: https://en.wikipedia.org/wiki/Variable-length_quantity\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` if the sequence to decode or encode is incomplete. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# if the sequence is incomplete\nraise ValueError(\"incomplete sequence\")\n```\n\nPlace the implementation in src/core/variable_length_quantity.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.variable_length_quantity import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/variable-length-quantity/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom variable_length_quantity import (\ndecode,\nencode,\n)\n\n\n\ndef test_zero(self):\n    assert encode([0x0]) == [0x0]\n\ndef test_arbitrary_single_byte(self):\n    assert encode([0x40]) == [0x40]\n\ndef test_largest_single_byte(self):\n    assert encode([0x7F]) == [0x7F]\n\ndef test_smallest_double_byte(self):\n    assert encode([0x80]) == [0x81, 0x0]\n\ndef test_arbitrary_double_byte(self):\n    assert encode([0x2000]) == [0xC0, 0x0]\n\ndef test_largest_double_byte(self):\n    assert encode([0x3FFF]) == [0xFF, 0x7F]\n\ndef test_smallest_triple_byte(self):\n    assert encode([0x4000]) == [0x81, 0x80, 0x0]\n\ndef test_arbitrary_triple_byte(self):\n    assert encode([0x100000]) == [0xC0, 0x80, 0x0]\n\ndef test_largest_triple_byte(self):\n    assert encode([0x1FFFFF]) == [0xFF, 0xFF, 0x7F]\n\ndef test_smallest_quadruple_byte(self):\n    assert encode([0x200000]) == [0x81, 0x80, 0x80, 0x0]\n\ndef test_arbitrary_quadruple_byte(self):\n    assert encode([0x8000000]) == [0xC0, 0x80, 0x80, 0x0]\n\ndef test_largest_quadruple_byte(self):\n    assert encode([0xFFFFFFF]) == [0xFF, 0xFF, 0xFF, 0x7F]\n\ndef test_smallest_quintuple_byte(self):\n    assert encode([0x10000000]) == [0x81, 0x80, 0x80, 0x80, 0x0]\n\ndef test_arbitrary_quintuple_byte(self):\n    assert encode([0xFF000000]) == [0x8F, 0xF8, 0x80, 0x80, 0x0]\n\ndef test_maximum_32_bit_integer_input(self):\n    assert encode([0xFFFFFFFF]) == [0x8F, 0xFF, 0xFF, 0xFF, 0x7F]\n\ndef test_two_single_byte_values(self):\n    assert encode([0x40 == 0x7F], [0x40, 0x7F])\n\ndef test_two_multi_byte_values(self):\n    assertEqual(\n        encode([0x4000, 0x123456]), [0x81, 0x80, 0x0, 0xC8, 0xE8, 0x56]\n    )\n\ndef test_many_multi_byte_values(self):\n    assertEqual(\n        encode([0x2000, 0x123456, 0xFFFFFFF, 0x0, 0x3FFF, 0x4000]),\n        [\n            0xC0,\n            0x0,\n            0xC8,\n            0xE8,\n            0x56,\n            0xFF,\n            0xFF,\n            0xFF,\n            0x7F,\n            0x0,\n            0xFF,\n            0x7F,\n            0x81,\n            0x80,\n            0x0,\n        ],\n    )\n\ndef test_one_byte(self):\n    assert decode([0x7F]) == [0x7F]\n\ndef test_two_bytes(self):\n    assert decode([0xC0 == 0x0], [0x2000])\n\ndef test_three_bytes(self):\n    assert decode([0xFF == 0xFF, 0x7F], [0x1FFFFF])\n\ndef test_four_bytes(self):\n    assert decode([0x81 == 0x80, 0x80, 0x0], [0x200000])\n\ndef test_maximum_32_bit_integer(self):\n    assert decode([0x8F == 0xFF, 0xFF, 0xFF, 0x7F], [0xFFFFFFFF])\n\ndef test_incomplete_sequence_causes_error(self):\n    with pytest.raises(ValueError) as err:\n        decode([0xFF])\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"incomplete sequence\"\n\ndef test_incomplete_sequence_causes_error_even_if_value_is_zero(self):\n    with pytest.raises(ValueError) as err:\n        decode([0x80])\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"incomplete sequence\"\n\ndef test_multiple_values(self):\n    assertEqual(\n        decode(\n            [\n                0xC0,\n                0x0,\n                0xC8,\n                0xE8,\n                0x56,\n                0xFF,\n                0xFF,\n                0xFF,\n                0x7F,\n                0x0,\n                0xFF,\n                0x7F,\n                0x81,\n                0x80,\n                0x0,\n            ]\n        ),\n        [0x2000, 0x123456, 0xFFFFFFF, 0x0, 0x3FFF, 0x4000],\n    )\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.variable_length_quantity import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for variable_length_quantity\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/variable_length_quantity.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}