{
  "id": "exercism_pascals_triangle",
  "name": "Pascals Triangle",
  "description": "Exercism: pascals_triangle",
  "tier": "tier1_standard",
  "prompt": "# Introduction\n\nWith the weather being great, you're not looking forward to spending an hour in a classroom.\nAnnoyed, you enter the class room, where you notice a strangely satisfying triangle shape on the blackboard.\nWhilst waiting for your math teacher to arrive, you can't help but notice some patterns in the triangle: the outer values are all ones, each subsequent row has one more value than its previous row and the triangle is symmetrical.\nWeird!\n\nNot long after you sit down, your teacher enters the room and explains that this triangle is the famous [Pascal's triangle][wikipedia].\n\nOver the next hour, your teacher reveals some amazing things hidden in this triangle:\n\n- It can be used to compute how many ways you can pick K elements from N values.\n- It contains the Fibonacci sequence.\n- If you color odd and even numbers differently, you get a beautiful pattern called the [Sierpi\u0144ski triangle][wikipedia-sierpinski-triangle].\n\nThe teacher implores you and your classmates to lookup other uses, and assures you that there are lots more!\nAt that moment, the school bell rings.\nYou realize that for the past hour, you were completely absorbed in learning about Pascal's triangle.\nYou quickly grab your laptop from your bag and go outside, ready to enjoy both the sunshine _and_ the wonders of Pascal's triangle.\n\n[wikipedia]: https://en.wikipedia.org/wiki/Pascal%27s_triangle\n[wikipedia-sierpinski-triangle]: https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle\n# Instructions\n\nYour task is to output the first N rows of Pascal's triangle.\n\n[Pascal's triangle][wikipedia] is a triangular array of positive integers.\n\nIn Pascal's triangle, the number of values in a row is equal to its row number (which starts at one).\nTherefore, the first row has one value, the second row has two values, and so on.\n\nThe first (topmost) row has a single value: `1`.\nSubsequent rows' values are computed by adding the numbers directly to the right and left of the current position in the previous row.\n\nIf the previous row does _not_ have a value to the left or right of the current position (which only happens for the leftmost and rightmost positions), treat that position's value as zero (effectively \"ignoring\" it in the summation).\n\n## Example\n\nLet's look at the first 5 rows of Pascal's Triangle:\n\n```text\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n```\n\nThe topmost row has one value, which is `1`.\n\nThe leftmost and rightmost values have only one preceding position to consider, which is the position to its right respectively to its left.\nWith the topmost value being `1`, it follows from this that all the leftmost and rightmost values are also `1`.\n\nThe other values all have two positions to consider.\nFor example, the fifth row's (`1 4 6 4 1`) middle value is `6`, as the values to its left and right in the preceding row are `3` and `3`:\n\n[wikipedia]: https://en.wikipedia.org/wiki/Pascal%27s_triangle\n# Instructions append\n\n## How this Exercise is Implemented in Python: Recursion\n\nThis exercise is designed to be completed using [concept:python/recursion](), rather than loops.\nA recursive function is a function that calls itself, which is useful when solving problems that are defined in terms of themselves.\nTo avoid infinite recursion (or more specifically, to avoid overflowing the stack), something called a \"base case\" is used.\nWhen the base case is reached, a non-recursive value is returned, which allows the previous function call to resolve and return its value, and so on, rippling back down the stack until the first function call returns the answer.\nWe could write a recursive function to find the answer to 5! (i.e. 5 * 4 * 3 * 2 * 1) like so:\n\n````python\ndef factorial(number):\n  if number <= 1:  # base case\n    return 1\n\n  return number * factorial(number - 1) # recursive case\n\nprint(factorial(5)) # returns 120\n````\n\nFinally, it should be noted that Python limits the number of times recursive calls can be made (1000 by default) and does not optimize for [tail recursion][tail-recursion].\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception][raising].\nWhen you do this, you should always include a **meaningful error message** to indicate what the source of the error is.\nThis makes your code more readable and helps significantly with debugging.\nFor situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types][built-in-errors], but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement][raise-statement] to \"throw\" multiple `ValueErrors` if the `rows()` function is passed a negative number.\nThe tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# if the rows function is passed a negative number.\nraise ValueError(\"number of rows is negative\")\n```\n\n[built-in-errors]: https://docs.python.org/3/library/exceptions.html#base-classes\n[raise-statement]: https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement\n[raising]: https://docs.python.org/3/tutorial/errors.html#raising-exceptions\n[tail-recursion]: https://www.geeksforgeeks.org/tail-recursion/\n\nPlace the implementation in src/core/pascals_triangle.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.pascals_triangle import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/pascals-triangle/canonical-data.json\n# File last updated on 2023-07-19\n\nimport sys\nimport unittest\n\nfrom pascals_triangle import (\nrows,\n)\n\nTRIANGLE = [\n[1],\n[1, 1],\n[1, 2, 1],\n[1, 3, 3, 1],\n[1, 4, 6, 4, 1],\n[1, 5, 10, 10, 5, 1],\n[1, 6, 15, 20, 15, 6, 1],\n[1, 7, 21, 35, 35, 21, 7, 1],\n[1, 8, 28, 56, 70, 56, 28, 8, 1],\n[1, 9, 36, 84, 126, 126, 84, 36, 9, 1],\n]\n\n\n\ndef test_zero_rows():\n    assert rows(0) == TRIANGLE[:0]\n\ndef test_single_row():\n    assert rows(1) == TRIANGLE[:1]\n\ndef test_two_rows():\n    assert rows(2) == TRIANGLE[:2]\n\ndef test_three_rows():\n    assert rows(3) == TRIANGLE[:3]\n\ndef test_four_rows():\n    assert rows(4) == TRIANGLE[:4]\n\ndef test_five_rows():\n    assert rows(5) == TRIANGLE[:5]\n\ndef test_six_rows():\n    assert rows(6) == TRIANGLE[:6]\n\ndef test_ten_rows():\n    assert rows(10) == TRIANGLE[:10]\n\n# Additional tests for this track\ndef test_negative_rows_are_invalid():\n    with pytest.raises(ValueError) as err:\n        rows(-1)\n        assert type(err.exception) == ValueError\n        assert err.exception.args[0] == \"number of rows is negative\"\n\ndef test_solution_is_recursive():\n    with pytest.raises(RecursionError) as err:\n        rows(sys.getrecursionlimit() + 10)\n        assert type(err.exception) == RecursionError\n        assertEqual(\n            err.exception.args[0][:32], \"maximum recursion depth exceeded\"\n        )\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.pascals_triangle import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for pascals_triangle\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/pascals_triangle.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}