{
  "id": "exercism_say",
  "name": "Say",
  "description": "Exercism: say",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nGiven a number from 0 to 999,999,999,999, spell out that number in English.\n\n## Step 1\n\nHandle the basic case of 0 through 99.\n\nIf the input to the program is `22`, then the output should be `'twenty-two'`.\n\nYour program should complain loudly if given a number outside the blessed range.\n\nSome good test cases for this program are:\n\n- 0\n- 14\n- 50\n- 98\n- -1\n- 100\n\n### Extension\n\nIf you're on a Mac, shell out to Mac OS X's `say` program to talk out loud.\nIf you're on Linux or Windows, eSpeakNG may be available with the command `espeak`.\n\n## Step 2\n\nImplement breaking a number up into chunks of thousands.\n\nSo `1234567890` should yield a list like 1, 234, 567, and 890, while the far simpler `1000` should yield just 1 and 0.\n\n## Step 3\n\nNow handle inserting the appropriate scale word between those chunks.\n\nSo `1234567890` should yield `'1 billion 234 million 567 thousand 890'`\n\nThe program must also report any values that are out of range.\nIt's fine to stop at \"trillion\".\n\n## Step 4\n\nPut it all together to get nothing but plain English.\n\n`12345` should give `twelve thousand three hundred forty-five`.\n\nThe program must also report any values that are out of range.\n# Instructions append\n\n## Exception messages\n\nSometimes it is necessary to [raise an exception](https://docs.python.org/3/tutorial/errors.html#raising-exceptions). When you do this, you should always include a **meaningful error message** to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the [built in error types](https://docs.python.org/3/library/exceptions.html#base-classes), but should still include a meaningful message.\n\nThis particular exercise requires that you use the [raise statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement) to \"throw\" a `ValueError` if the number input to `say()` is out of range. The tests will only pass if you both `raise` the `exception` and include a message with it.\n\nTo raise a `ValueError` with a message, write the message as an argument to the `exception` type:\n\n```python\n# if the number is negative\nraise ValueError(\"input out of range\")\n\n# if the number is larger than 999,999,999,999\nraise ValueError(\"input out of range\")\n```\n\nPlace the implementation in src/core/say.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.say import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/say/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom say import (\nsay,\n)\n\n\n\ndef test_zero(self):\n    assert say(0) == \"zero\"\n\ndef test_one(self):\n    assert say(1) == \"one\"\n\ndef test_fourteen(self):\n    assert say(14) == \"fourteen\"\n\ndef test_twenty(self):\n    assert say(20) == \"twenty\"\n\ndef test_twenty_two(self):\n    assert say(22) == \"twenty-two\"\n\ndef test_thirty(self):\n    assert say(30) == \"thirty\"\n\ndef test_ninety_nine(self):\n    assert say(99) == \"ninety-nine\"\n\ndef test_one_hundred(self):\n    assert say(100) == \"one hundred\"\n\ndef test_one_hundred_twenty_three(self):\n    assert say(123) == \"one hundred twenty-three\"\n\ndef test_two_hundred(self):\n    assert say(200) == \"two hundred\"\n\ndef test_nine_hundred_ninety_nine(self):\n    assert say(999) == \"nine hundred ninety-nine\"\n\ndef test_one_thousand(self):\n    assert say(1000) == \"one thousand\"\n\ndef test_one_thousand_two_hundred_thirty_four(self):\n    assert say(1234) == \"one thousand two hundred thirty-four\"\n\ndef test_one_million(self):\n    assert say(1000000) == \"one million\"\n\ndef test_one_million_two_thousand_three_hundred_forty_five(self):\n    assertEqual(\n        say(1002345), \"one million two thousand three hundred forty-five\"\n    )\n\ndef test_one_billion(self):\n    assert say(1000000000) == \"one billion\"\n\ndef test_a_big_number(self):\n    assertEqual(\n        say(987654321123),\n        \"nine hundred eighty-seven billion six hundred fifty-four million three hundred twenty-one thousand one hundred twenty-three\",\n    )\n\ndef test_numbers_below_zero_are_out_of_range(self):\n    with pytest.raises(ValueError) as err:\n        say(-1)\n\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"input out of range\"\n\ndef test_numbers_above_999_999_999_999_are_out_of_range(self):\n    with pytest.raises(ValueError) as err:\n        say(1000000000000)\n\n    assert type(err.exception) == ValueError\n    assert err.exception.args[0] == \"input out of range\"\n\n# Additional tests for this track\ndef test_one_hundred_seventy(self):\n    assert say(170) == \"one hundred seventy\"\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.say import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for say\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/say.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}