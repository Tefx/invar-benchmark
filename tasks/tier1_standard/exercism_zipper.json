{
  "id": "exercism_zipper",
  "name": "Zipper",
  "description": "Exercism: zipper",
  "tier": "tier1_standard",
  "prompt": "# Instructions\n\nCreating a zipper for a binary tree.\n\n[Zippers][zipper] are a purely functional way of navigating within a data structure and manipulating it.\nThey essentially contain a data structure and a pointer into that data structure (called the focus).\n\nFor example given a rose tree (where each node contains a value and a list of child nodes) a zipper might support these operations:\n\n- `from_tree` (get a zipper out of a rose tree, the focus is on the root node)\n- `to_tree` (get the rose tree out of the zipper)\n- `value` (get the value of the focus node)\n- `prev` (move the focus to the previous child of the same parent,\n  returns a new zipper)\n- `next` (move the focus to the next child of the same parent, returns a\n  new zipper)\n- `up` (move the focus to the parent, returns a new zipper)\n- `set_value` (set the value of the focus node, returns a new zipper)\n- `insert_before` (insert a new subtree before the focus node, it\n  becomes the `prev` of the focus node, returns a new zipper)\n- `insert_after` (insert a new subtree after the focus node, it becomes\n  the `next` of the focus node, returns a new zipper)\n- `delete` (removes the focus node and all subtrees, focus moves to the\n  `next` node if possible otherwise to the `prev` node if possible,\n  otherwise to the parent node, returns a new zipper)\n\n[zipper]: https://en.wikipedia.org/wiki/Zipper_%28data_structure%29\n\nPlace the implementation in src/core/zipper.py",
  "initial_files": {},
  "test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.zipper import *\n\n# These tests are auto-generated with test data from:\n# https://github.com/exercism/problem-specifications/tree/main/exercises/zipper/canonical-data.json\n# File last updated on 2023-07-19\n\nimport unittest\n\nfrom zipper import (\nZipper,\n)\n\n\n\ndef test_data_is_retained(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.to_tree()\n    assert result == expected\n\ndef test_left_right_and_value(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().right().value()\n    assert result == 3\n\ndef test_dead_end(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().left()\n    assertIsNone(result)\n\ndef test_tree_from_deep_focus(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().right().to_tree()\n    assert result == expected\n\ndef test_traversing_up_from_top(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.up()\n    assertIsNone(result)\n\ndef test_left_right_and_up(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().up().right().up().left().right().value()\n    assert result == 3\n\ndef test_test_ability_to_descend_multiple_levels_and_return(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().right().up().up().value()\n    assert result == 1\n\ndef test_set_value(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 5,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().set_value(5).to_tree()\n    assert result == expected\n\ndef test_set_value_after_traversing_up(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 5,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().right().up().set_value(5).to_tree()\n    assert result == expected\n\ndef test_set_left_with_leaf(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": {\"value\": 5, \"left\": None, \"right\": None},\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = (\n        zipper.left().set_left({\"value\": 5, \"left\": None, \"right\": None}).to_tree()\n    )\n    assert result == expected\n\ndef test_set_right_with_null(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\"value\": 2, \"left\": None, \"right\": None},\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().set_right(None).to_tree()\n    assert result == expected\n\ndef test_set_right_with_subtree(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\n            \"value\": 6,\n            \"left\": {\"value\": 7, \"left\": None, \"right\": None},\n            \"right\": {\"value\": 8, \"left\": None, \"right\": None},\n        },\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.set_right(\n        {\n            \"value\": 6,\n            \"left\": {\"value\": 7, \"left\": None, \"right\": None},\n            \"right\": {\"value\": 8, \"left\": None, \"right\": None},\n        }\n    ).to_tree()\n    assert result == expected\n\ndef test_set_value_on_deep_focus(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    expected = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 5, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n\n    zipper = Zipper.from_tree(initial)\n    result = zipper.left().right().set_value(5).to_tree()\n    assert result == expected\n\ndef test_different_paths_to_same_zipper(self):\n    initial = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n    result = Zipper.from_tree(initial).left().up().right().to_tree()\n\n    final = {\n        \"value\": 1,\n        \"left\": {\n            \"value\": 2,\n            \"left\": None,\n            \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n        },\n        \"right\": {\"value\": 4, \"left\": None, \"right\": None},\n    }\n    expected = Zipper.from_tree(final).right().to_tree()\n\n    assert result == expected\n",
  "hidden_test_file": "import pytest\nimport sys\nsys.path.insert(0, 'src')\nfrom core.zipper import *\n\n# Support both ValueError and deal.PreContractError for contract violations\ntry:\n    import deal\n    CONTRACT_ERROR = (ValueError, deal.PreContractError)\nexcept ImportError:\n    CONTRACT_ERROR = ValueError\n\n\n# Edge case tests for zipper\n# These test boundary conditions and error handling\n\ndef test_edge_case_empty_input():\n    \"\"\"Test behavior with empty input if applicable.\"\"\"\n    # This is a placeholder - actual edge cases depend on the function\n    pass\n\ndef test_edge_case_large_input():\n    \"\"\"Test behavior with large input if applicable.\"\"\"\n    pass\n",
  "expected_files": [
    "src/core/zipper.py"
  ],
  "tags": [
    "exercism",
    "tier1"
  ],
  "difficulty": "hard"
}